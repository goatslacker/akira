rx = {
  IDENTIFIER = /^([a-zA-Z_$][0-9a-zA-Z_\-$]*)/
  NUMBER = /^((\d+\.)?\d+)+/
  STRING = /^'(.*?)'/
  LAMBDA = /^->/
  OPERATION = /^(<=|>=|>|<|==|!=|\|\||\&\&|≤|≥)+/
  NEWLINE = /^\n/
  REGEX = /^(\/((?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*)\/)([imgy]{0,4})(?!\w)/
#  javascriptStart = /^<%/
#  javascriptEnd = /^%>/
  COMMENTS = /^#/
  WHITESPACE = /^ /
}

KEYWORDS = ['arguments', 'construct', 'if', 'then', 'else', 'import', 'export']
COMPARE = ['==', '!=', '>', '>=', '<', '<=', 'is', 'not']
LOGIC = ['and', 'or', '&&', '||']
BOOLEAN = ['true', 'false']
UTILS = [
  'arrEq'
  'assert'
  'at'
  'call'
  'consts'
  'div'
  'eq'
  'filter'
  'flip'
  'foldl'
  'foldr'
  'get'
  'head'
  'init'
  'last'
  'length'
  'map'
  'mod'
  'neq'
  'partial'
  'pop'
  'print'
  'prod'
  'range'
  'sub'
  'sum'
  'square'
  'tail'
]


filter-tokens-fn(a) -> partial: filter, (= x -> call: (get: rx, x), 'test', a)

get-type(a) -> (
  filter-tokens = filter-tokens-fn: a
  rx | Object.keys | filter-tokens | pop
)

extract(key, chunk) -> call: (get: rx, key), 'exec', chunk

parse-alphanumeric(t, chunk) -> (
  exec = extract: t, chunk
  exec.2
)

parse-identifier(t, chunk) -> (
  exec = extract: t, chunk
  item = exec.2
# check if it's a keyword, logic, bool, or utils here
  item
)

get-token(chunk, t) =
  'IDENTIFIER'  -> parse-identifier: t, chunk
  'NUMBER' -> parse-alphanumeric: t, chunk
  'STRING' -> parse-alphanumeric: t, chunk
  'LAMBDA' -> '->'

process-chunk(code, line) -> (
  type = get-type: code
  token = get-token: code, type
  [token, type, line]
)

return-tokens(code, i, line) -> (
  tokens = []
  len = length: code
  chunk = code.substr: i, len

  if chunk
    then (
      token = process-chunk: chunk, line
      token-length = length: token.1
      tokens.push: token
      tokens.concat: (return-tokens: code, i + token-length, 0)
    )
    else tokens
)

tokenize(code) -> return-tokens: (code.trim: ()), 0, 0

print: (tokenize: '2')
