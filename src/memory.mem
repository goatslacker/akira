fs = require: 'fs'
path = require: 'path'
util = require: 'util'
vm = require: 'vm'
escodegen = require: 'escodegen'
me = require: '../package.json'

lexer = require: './lexer'
Parser = require: './parser'
parser = Parser.parser
parser.yy <+ require: './nodes';

tokenize(code) -> lexer.tokenize: code
parse(tokens) -> parser.parse: tokens
ast(parsed) -> (
  self = Object.create: {}
  body = parsed.compile: self
  ast = parsed.getUtils: self; ++ parsed.addVars: self; ++ body
  program = {
    type = 'Program'
    body = ast
  }
)
wrap(program) -> (
  [
    '(function () {'
    escodegen.generate: program;
    '}.call(typeof module !== "undefined" ? module.exports : this))'
  ]
)


compile(code) -> code | tokenize | parse | ast | wrap

file(filepath) -> path.join: process.env.PWD, filepath | fs.read-file-sync | @.to-string:!

run(code) -> (
  try (
    result = vm.run-in-new-context: (code.join: ''), { console = console }
  ) catch (
    util.error: err.stack
    util.debug: code
  )
  result
)


output(list) -> map: (\x -> x | util.puts), list
analyze(body) -> body | util.inspect: @, false, 50 | util.puts

write(code, item) -> (
  filepath = item.replace: 'src', 'lib' | @.replace: '.mem', '.js' | path.join: process.env.PWD, @
  code | join-lines | fs.write-file-sync: filepath, @
)

#main
memory(item, action)
  'compile' -> file: item | compile | write: @, item
  'code' -> file: item | compile | output
  'test' -> file: 'test/tests.mem' | compile | run
  'run' -> file: item | compile | run
  'tokens' -> file: item | tokenize | analyze
  'ast' -> file: item | tokenize | parse | ast | analyze
  'version' -> 'memory ' ++ me.version | util.puts

export memory
