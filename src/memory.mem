fs = require: 'fs'
path = require: 'path'
util = require: 'util'
vm = require: 'vm'
escodegen = require: 'escodegen'
nodewatch = require: 'nodewatch'
me = require: '../package.json'

lexer = require: './lexer'
Parser = require: './parser'
parser = Parser.parser
parser.yy <+ require: './nodes';

tokenize(code) -> lexer.tokenize: code
parse(tokens) -> parser.parse: tokens
ast(parsed) -> (
  self = Object.create: {}
  body = parsed.compile: self
  ast = parsed.getUtils: self; ++ parsed.addVars: self; ++ body
  program = {
    type = 'Program'
    body = ast
  }
)
wrap(program) -> (
  [
    '(function () {'
    escodegen.generate: program;
    '}.call(typeof module !== "undefined" ? module.exports : this))'
  ]
)


compile(code) -> code | tokenize | parse | ast | wrap

walk(tree, cb) -> (
  try (
    stat = fs.stat-sync: tree
  ) catch (
    raise: err
  )

  if stat.is-directory:!
    then fs.readdir-sync: tree | map: (\v -> path.join: tree, v | walk: @, cb), @
    else (
      if tree.index-of: '.mem'; >= 0
        then file: tree | cb: @, tree
        else none
    )
)


file(filepath) -> path.join: process.env.PWD, filepath | fs.read-file-sync | @.to-string:!
files(dirname, cb) -> (
  stat = fs.stat-sync: dirname
  if stat.is-directory:!
    then walk: dirname, cb
    else file: dirname | cb: @, dirname
)

run(code) -> (
  try (
    result = vm.run-in-new-context: (code.join: ''), { console = console }
  ) catch (
    util.error: err.stack
    util.debug: code
  )
  result
)


output(list) -> map: (\x -> x | util.puts), list
analyze(body) -> body | util.inspect: @, false, 50 | util.puts

write(code, item) -> (
  filepath = item.replace: 'src', 'lib' | @.replace: '.mem', '.js' | path.join: process.env.PWD, @
  code | join-lines | fs.write-file-sync: filepath, @
)

watch(filename) -> nodewatch.add: filename;.onChange: (\-> file: filename | compile | write: @, filename)

#main
memory(item, action)
  'compile' -> files: item, (\code, name -> code | compile | write: @, name)
  'code' -> file: item | compile | output
  'test' -> file: 'test/tests.mem' | compile | run
  'run' -> file: item | compile | run
  'tokens' -> file: item | tokenize | analyze
  'ast' -> file: item | tokenize | parse | ast | analyze
  'version' -> 'memory ' ++ me.version | util.puts
  'watch' -> watch: item

export memory
