fs = require: 'fs'
path = require: 'path'
util = require: 'util'
vm = require: 'vm'
escodegen = require: 'escodegen'
nodewatch = require: 'nodewatch'
me = require: '../package.json'

lexer = require: './lexer'
Parser = require: './parser'
parser = Parser.parser
parser.yy <+ require: './nodes';

tokenize = \code -> lexer.tokenize: code
parse = \tokens -> parser.parse: tokens
ast = \parsed {
  self = Object.create: {}
  body = parsed.compile: self
  ast = parsed.getUtils: self; ++ parsed.addVars: self; ++ body
  program = {
    type := 'Program'
    body := ast
  }
}
wrap = \program {
  [
    '(function () {'
    escodegen.generate: program;
    '}.call(typeof module !== "undefined" ? module.exports : this))'
  ]
}


compile = \code -> code | tokenize | parse | ast | wrap

walk = \tree, cb {
  try {
    stat = fs.stat-sync: tree
  } catch {
    raise: err
  }

  if stat.is-directory:!
    then fs.readdir-sync: tree | map: (\v -> path.join: tree, v | walk: @, cb), @
    else {
      if tree.index-of: '.mem'; >= 0
        then file: tree | cb: @, tree
        else none
    }
}


file = \filepath -> path.join: process.env.PWD, filepath | fs.read-file-sync | @.to-string:!
files = \dirname, cb {
  stat = fs.stat-sync: dirname
  if stat.is-directory:!
    then walk: dirname, cb
    else file: dirname | cb: @, dirname
}

run = \code {
  try {
    result = vm.run-in-new-context: (code.join: ''), { console := console }
  } catch {
    util.error: err.stack
    util.debug: code
  }
  result
}


output = \list -> map: (\x -> x | util.puts), list
analyze = \body -> body | util.inspect: @, false, 50 | util.puts

write = \code, item {
  filepath = item.replace: 'src', 'lib' | @.replace: '.mem', '.js' | path.join: process.env.PWD, @
  code | join-lines | fs.write-file-sync: filepath, @
}

watch = \filename -> nodewatch.add: filename;.onChange: (\none -> file: filename | compile | write: @, filename)

display-help = \none {
  util.puts: '               memory'
  util.puts: ''
  util.puts: 'ast [file]     - output the Mozilla Parse API for that file'
  util.puts: 'compile [file] - compile to JavaScript'
  util.puts: 'code [file]    - compile to JS and output'
  util.puts: 'run [file]     - compile and interpret said file'
  util.puts: 'test           - run memory unit tests'
  util.puts: 'tokens [file]  - output the lexer tokens for that file'
  util.puts: 'version        - memory version'
  util.puts: 'watch [file]   - watch a file for changes and compile on change'
  util.puts: ''
}

#main
memory(item, action)
  'compile' -> files: item, (\code, name -> code | compile | write: @, name)
  'code' -> file: item | compile | output
  'test' -> file: 'test/tests.mem' | compile | run
  'run' -> file: item | compile | run
  'tokens' -> file: item | tokenize | analyze
  'ast' -> file: item | tokenize | parse | ast | analyze
  'version' -> 'memory ' ++ me.version | util.puts
  'watch' -> watch: item
  otherwise -> display-help:!

export memory
