fs = require: 'fs'
path = require: 'path'
util = require: 'util'
vm = require: 'vm'
escodegen = require: 'escodegen'
nodewatch = require: 'nodewatch'
me = require: '../package.json'

lexer = require: './lexer'
parser = require: './grammar'
parser.yy <+ (require: './nodes')

tokenize = \code -> lexer: code
parse = \tokens -> parser.parse: tokens
ast = \parsed, name, context, evald -> {
  self = context || ({})
  body = parsed.compile: self, name
  ast = (parsed.get-utils: self) ++ (parsed.add-vars: self, evald) ++ body

  xform = ({
    type = 'CallExpression'
    callee = ({
      type = 'FunctionExpression'
      id = none
      params = [({ type = 'Identifier', name = '$$export' })]
      body = ({
        type = 'BlockStatement'
        body = ast
      })
    })
    arguments = []
  })

  program = ({
    type = 'Program'
    body = [({ type = 'ExpressionStatement', expression = xform })]
  })
}
generate = \program -> escodegen.generate: program
wrap = \code -> {
  [
    'var $$MEMORY = (typeof module !== "undefined") ? module : {};'
    '$$MEMORY.exports = ' ++ code
  ]
}

compile = \code, name, context, evald -> no-wrap: code, name, context, evald | wrap
no-wrap = \code, name, context, evald -> code | tokenize | parse | ast: @, name, context, evald | generate

walk = \tree, cb -> {
  try {
    stat = fs.stat-sync: tree
  } catch {
    raise err
  }

  if stat.is-directory!
    then fs.readdir-sync: tree | map: (\v -> path.join: tree, v | walk: @, cb), @
    else {
      if (tree.index-of: '.mem') >= 0
        then file: tree | cb: @, tree
        else none
    }
}


file = \filepath -> path.join: process.env.PWD, filepath | fs.read-file-sync | @.to-string!
files = \dirname, cb -> {
  stat = fs.stat-sync: dirname
  if stat.is-directory!
    then walk: dirname, cb
    else file: dirname | cb: @, dirname
}

run = \code -> {
  try {
    result = vm.run-in-new-context: (code.join: ''), ({ console = console })
  } catch {
    util.error: err.stack
    util.debug: code
  }
  result
}


output = \list -> map: (\x -> x | util.puts), list
analyze = \body -> body | util.inspect: @, false, 50 | util.puts

write = \code, item -> {
  filepath = item.replace: 'src', 'lib' | @.replace: '.mem', '.js' | path.join: process.env.PWD, @
  code | join-lines | fs.write-file-sync: filepath, @
}

watch = \filename -> nodewatch.add: filename | @.on-change: (\-> file: filename | compile | write: @, filename)

display-help = \-> {
  util.puts: '               memory'
  util.puts: ''
  util.puts: 'ast [file]     - output the Mozilla Parse API for that file'
  util.puts: 'compile [file] - compile to JavaScript'
  util.puts: 'code [file]    - compile to JS and output'
  util.puts: 'run [file]     - compile and interpret said file'
  util.puts: 'test           - run memory unit tests'
  util.puts: 'tokens [file]  - output the lexer tokens for that file'
  util.puts: 'version        - memory version'
  util.puts: 'watch [file]   - watch a file for changes and compile on change'
  util.puts: ''
}

start-repl = \-> {
  context = ({})
  repl: (\data -> {
    no-wrap: data, 'repl', context, true | eval | print
    prompt!
  })
  prompt!
}

prompt = \chunk -> process.stdout.write: 'memory> '

repl = \fn -> {
  stdin = process.open-stdin!
  stdin.set-encoding: 'utf8'
  stdin.on: 'data', fn
}

#main
export memory = \action, item
  'compile' -> files: item, (\code, name -> code | compile: @, item | write: @, name)
  'code' -> file: item | compile: @, item | output
  'test' -> file: 'test/tests.mem' | compile: @, 'test/tests.mem' | run
  'run' -> file: item | compile: @, item | run
  'tokens' -> file: item | tokenize | analyze
  'ast' -> file: item | tokenize | parse | ast: @, item | analyze
  'version' -> 'memory ' ++ me.version | util.puts
  'watch' -> watch: item
  'help' -> display-help!
  else -> start-repl!
