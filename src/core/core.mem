macro bin-expr fn [op a b] {
  @type 'BinaryExpression'
  @operator op.value
  @left a
  @right b
}

macro each fn [sym name ifstmt] {
  @type 'ForInStatement'
  @left {
    @type 'VariableDeclaration'
    @declarations [{
      @type 'VariableDeclarator'
      @id sym
      @init none
    }]
    @kind 'var'
  }
  @right name
  @body {
    @type 'BlockStatement'
    @body [{
      @type 'IfStatement'
      @test ifstmt.test
      @consequent {
        @type 'BlockStatement'
        @body [{
          @type 'ReturnStatement'
          @argument sym
        }]
      }
      @alternate none
    }]
  }
  @each false
}

export {

  @eq (`
    eq = fn [a b] a == b)

  @neq (`
    neq = fn [a b] a != b)

  @gt (`
    gt = fn [a b] a > b)

  @lt (`
    lt = fn [a b] a < b)

  @gte (`
    gte = fn [a b] a >= b)

  @lte (`
    lte = fn [a b] a <= b)

  @and (`
    and = fn [a b] a && b)

  @or (`
    or = fn [a b] a || b)

  @head (`
    head = fn [[x]] x)

  @init (`
    init = fn [[& xs x]] xs)

  @tail (`
    tail = fn [[x & xs]] xs)

  @last (`
    last = fn [[& xs x]] x)

  @get (`
    get = fn [obj prop] obj !! prop)

  @length (`
    length = fn [of] of.length)

  @join (`
    join = fn [by vec] vec.join: by)

  @concat (`
    concat = fn [& args] foldl: (fn [a b] a ++ b) args)

  @count (`
    count = fn [vec f]
      not f ? vec.length
      else ? filter: f vec | (.length)
  )

  @average (`
    average = fn [vec] foldl: (fn [a b] a + b) vec | (/ vec.length))

  @compact (`
    compact = fn [vec] filter: (fn [x] not not x) vec)

  @assert (`
    assert = fn [a b]
      a != b ? raise [a b]
      else ? none
  )

  @assert-deep (`
    assert-deep = fn [a b] filter: (fn [x i] assert: x (b !! i)) a)

  @find (`
    find = fn [f ds] each i ds (if (f: ds !! i) is true then 0 else 0))

  @call (`
    call = fn [obj prop & args] (obj !! prop) | (.apply: obj, args))

  @filter (`
    filter = fn [f vec] Array.prototype.filter.call: vec f)

  @map (`
    map = fn [f vec] Array.prototype.map.call: vec f)

  @foldl (`
    foldl = fn [f vec] Array.prototype.reduce.call: vec f)

  @foldr (`
    foldr = fn [f vec] Array.prototype.reduce-right.call: vec f)

  @intersect (`
    intersect = fn [vec1 vec2] filter: (fn [x] vec2.indexOf: x | (!= 0 - 1)) vec1)

  @max (`
    max = fn [vec] foldl: (fn [a b] if a > b then a else b) vec)

  @min (`
    min = fn [vec] foldl: (fn [a b] if a < b then a else b) vec)

  @nothing (`
    nothing = fn [f vec] filter: f vec | (.length) | (== 0))

  @randomize (`
    randomize = fn [vec] sort: (fn [] (Math.random!) > 0.5) vec)

  @unique (`
    unique = fn [vec] filter: (fn [x i] vec.indexOf: x | (== i)) vec)

  @take (`
    take = fn [n vec] vec.slice: 0 n)

  @drop (`
    drop = fn [n vec] vec.slice: n)

  @take-while (`
    take-while = fn [f [x & xs]]
      (f: x) == true ? x +: (take-while: f xs)
      else ? []
  )

  @apply (`
    apply = fn [f & args] f.apply: f args)

  @id (`
    id = fn [a] a)

  @flip (`
    flip = fn [f a b] f: b a)

  @partial (`
    partial = fn [f & args] fn [& xargs] f.apply: f, args ++ xargs)

  @partialr (`
    partialr = fn [f & args] fn [& xargs] f.apply: f, xargs ++ args)

  -- curry = fn [f] {
  --   c = fn [(args = [])] fn [arg] {
  --     xargs = args ++ arg
  --     if xargs.length < f.length then c: xargs else f.apply: f, xargs
  --   }
  --
  --   if f.length < 1 then f else c: none
  -- }
  -- curryr = fn [f] {
  --   c = fn [(args = [])] fn [arg] {
  --     xargs = arg +: args
  --     if xargs.length < f.length then c: xargs else f.apply: f, xargs
  --   }
  --
  --   if f.length < 1 then f else c: none
  -- }

  @show (`
    show = fn [i] i.to-string!)

  @mod (`
    mod = fn [a b] bin-expr '%' a b)

  @bit-and (`
    bit-and = fn [a b] bin-expr '&' a b)

  @bit-or (`
    bit-or = fn [a b] bin-expr '|' a b)

  @bit-xor (`
    bit-xor = fn [a b] bin-expr '^' a b)

  @bit-shiftl (`
    bit-shiftl = fn [a b] bin-expr '<<' a b)

  @bit-shiftr (`
    bit-shiftr = fn [a b] bin-expr '>>' a b)

  @bit-ushiftr (`
    bit-ushiftr = fn [a b] bin-expr '>>>' a b)

  @square (`
    square = fn [x] x * x)

  @sum (`
    sum = fn [a b] a + b)

  @sub (`
    sub = fn [a b] a - b)

  @prod (`
    prod = fn [a b] a * b)

  @div (`
    div = fn [a b] a / b)

  @even (`
    even = fn [n] (bin-expr '%' n 2) | (== 0))

  @odd (`
    odd = fn [n] (bin-expr '%' n 2) | (!= 0))

  @abs (`
    abs = fn [n] Math.abs: n)

  @sqrt (`
    sqrt = fn [n] Math.sqrt: n)

  @pow (`
    pow = fn [a b] Math.pow: a b)

  @str? (`
    str? = fn [x] x is String)

  @map? (`
    map? = fn [x] x is Object)

  @none? (`
    none? = fn [x] x is none)

  @camelize (`
    camelize = fn [str] str.replace: /(-|_)+([a-zA-Z0-9$_])/g,
      (fn [i] i.2.to-upper-case!))

  @uppercase (`
    uppercase = fn [str] str.to-upper-case!)

  @capitalize (`
    capitalize = fn [str] (str.1.to-upper-case!) ++ (str.slice: 1))

  @chars (`
    chars = fn [f str] str.split: '' | map: f)

  @condense (`
    condense = fn [str] str.replace: /\ /g '')

  @lines (`
    lines = fn [f str] str.split: '\n' | map: f)

  @words (`
    words = fn [f str] str.split: ' ' | map: f)

  @print (`
    print = fn [& args] console.log.apply: console args)
}
