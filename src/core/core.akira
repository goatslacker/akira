macro bin-expr fn [op a b] {
  { @type 'BinaryExpression'
  @operator op.value
  @left a
  @right b }
}

macro each fn [sym name test] {
  { @type 'ForInStatement'
  @left {
    @type 'VariableDeclaration'
    @declarations [{
      @type 'VariableDeclarator'
      @id sym
      @init none
    }]
    @kind 'var'
  }
  @right name
  @body {
    @type 'BlockStatement'
    @body [{
      @type 'IfStatement'
      @test test
      @consequent {
        @type 'BlockStatement'
        @body [{
          @type 'ReturnStatement'
          @argument sym
        }]
      }
      @alternate none
    }]
  }
  @each false }
}

macro obj-set fn [obj key val] {
  { @type 'AssignmentExpression'
  @operator '='
  @left {
    @type 'MemberExpression'
    @computed true
    @object obj
    @property key
  }
  @right val }
}

macro decrement fn [i] {
  { @type 'UpdateExpression' @operator '--' @argument i @prefix true }
}

macro push fn [vec i v] {
  { @type 'AssignmentExpression'
    @operator '='
    @left { @type 'MemberExpression'
            @computed true
            @object vec
            @property i }
    @right v }
}

export {
  @eq fn [a b] { a == b }

  @eq-val fn [a b] { a if a is b }

  @deep-eq fn [a b] {
      if a.length isnt b.length
        then false
        else if a.length is 0
          then false
          else zip-with (==) a b | foldl (&&) | eq true }

  @neq fn [a b] { a != b }

  @gt fn [a b] { a > b }

  @lt fn [a b] { a < b }

  @gte fn [a b] { a >= b }

  @lte fn [a b] { a <= b }

  @and fn [a b] { a && b }

  @or fn [a b] { a || b }

  @head fn [[x]] { x }

  @init fn [[& xs x]] { xs }

  @tail fn [[x & xs]] { xs }

  @last fn [xs] { xs !! xs.length - 1 }

  @get fn [obj prop] { obj !! prop }

  @length fn [of] { of.length }

  @join fn [by vec] { vec.join by }

  @reverse fn [coll] { coll.reverse! }

  @to-map fn [f coll] {
      x = {}
      coll.for-each fn [i] {
        [key val] = f i
        obj-set x key val
      }
      x
    }

  @concat (match {
      [a] a
      [a b] a ++ b
      [a b c] a ++ b ++ c
      [& a] foldl fn [a b] { a ++ b } a
    })

  @count (match {
      [vec] vec.length
      [vec f] filter f vec | (.length)
    })

  @zip-with fn [f [a & as] [b & bs]] {
      if (a is undefined) || (b is undefined)
        then []
        else (f a b) +: (zip-with f as bs) }

  @average fn [vec] {
      foldl sum vec | (/ vec.length) }

  @compact fn [vec] { filter (-> Boolean &0) vec }

  @flatten fn [vec (f = Array.is-array)] {
      result = []
      vec.for-each (fn [x] {
        if f x
          then flatten x | Array.prototype.push.apply result
          else result.push x
      })
      result
    }

  @concat-map fn [f vec] {
      result = []
      vec.for-each (fn [x] {
        item = f x
        if Array.isArray item
          then Array.prototype.push.apply result item
          else result.push item
      })
      result
    }

  @assert fn [a b] {
      if a != b
        then {
          raise 'Expected {{a}} == {{b}}'
          false
        }
        else true
    }

  @find fn [f ds] { each i ds ((f ds !! i) is true) }

  @call fn [obj prop & args] { (obj !! prop) | (.apply obj, args) }

  @keys Object.keys

  @values fn [x] { map fn [k] { x !! k } (keys x) }

  @key fn [v x] { find (== v) x }

  @value fn [k x] { x !! k }

  @filter fn [f vec] {
      Array.prototype.filter.call vec (-> f &0) }

  @map fn [f vec] {
      Array.prototype.map.call vec (-> f &0) }

  @foldl (match {
      [f vec] {
        if vec.length is 0
          then []
          else Array.prototype.reduce.call vec (-> f &0 &1)
      }
      [f vec a] {
        if vec.length is 0
          then []
          else Array.prototype.reduce.call ([a] ++ vec) (-> f &0 &1)
      }
    })

  @foldr fn [f vec] {
      if vec.length is 0
        then []
        else Array.prototype.reduce-right.call vec (-> f &0 &1) }

  @asyncmap fn [f vec cb] {
      count = vec.length
      results = []
      next = fn [i] fn [value] {
        decrement count
        push results i value
        (cb results) if count is 0
      }
      vec.for-each fn [x i] { f x next << i }
    }

  @intersect fn [vec1 vec2] {
      filter (-> vec2.indexOf &0 | (!= -1)) vec1 }

  @max fn [vec] {
      foldl (fn [a b] { if a > b then a else b }) vec }

  @min fn [vec] {
      foldl (fn [a b] { if a < b then a else b }) vec }

  @nothing fn [f vec] { filter f vec | (.length) | (== 0) }

  @randomize fn [vec] {
      sort (-> (Math.random!) > 0.5) vec }

  @take fn [n vec] { vec.slice 0 n }

  @drop fn [n vec] { vec.slice n }

  @take-while fn [f [x & xs]] {
      if (f x) is true
        then x +: (take-while f xs)
        else [] }

  @apply fn [f & args] { f.apply f args }

  @compose fn [f g] { fn [x] { x | g | f } }

  @sequence fn [f g] { fn [x] { x | f | g } }

  @id fn [a] { a }

  @flip fn [f a b] { f b a }

  @partial fn [f & args] {
      fn [& xargs] { f.apply f, args ++ xargs } }

  @partialr fn [f & args] {
      fn [& xargs] { f.apply f, xargs ++ args } }

  @curry fn [f] {
      l = f.length
      c = fn [args] {
        fn [& arg] {
          xargs = args ++ arg
          if xargs.length < l then c xargs else f.apply f, xargs
        }
      }
      if l < 1 then f else c []
    }

  @bind fn [f & args] {
      fn [] { f.apply f args }
    }

  @maybe-seq fn [& args] {
      foldl (fn [a b] {
        if a is none then none else b a
      }) ([true] ++ args)
    }

  @show fn [i] { i.to-string! }

  @mod fn [a b] { bin-expr '%' a b }

  @bit-and fn [a b] { bin-expr '&' a b }

  @bit-or fn [a b] { bin-expr '|' a b }

  @bit-xor fn [a b] { bin-expr '^' a b }

  @bit-shiftl fn [a b] { bin-expr '<<' a b }

  @bit-shiftr fn [a b] { bin-expr '>>' a b }

  @bit-ushiftr fn [a b] { bin-expr '>>>' a b }

  @square fn [x] { x * x }

  @sum fn [a b] { a + b }

  @sub fn [a b] { a - b }

  @prod fn [a b] { a * b }

  @div fn [a b] { a / b }

  @even fn [n] { (bin-expr '%' n 2) | (== 0) }

  @odd fn [n] { (bin-expr '%' n 2) | (!= 0) }

  @abs fn [n] { Math.abs n }

  @sqrt fn [n] { Math.sqrt n }

  @pow fn [a b] { Math.pow a b }

  @inc fn [x] { x + 1 }

  @dec fn [x] { x - 1 }

  @false? fn [x] { x is false }

  @true? fn [x] { x is true }

  @pos? fn [x] { x > 0 }

  @neg? fn [x] { x < 0 }

  @zero? fn [x] { x is 0 }

  @num? fn [x] { x is Number }

  @str? fn [x] { x is String }

  @map? fn [x] { x is Map }

  @vector? fn [x] { x is Vector }

  @bool? fn [x] { x is true || x is false }

  @none? fn [x] { x is none }

  @camelize fn [str] {
      str.replace /(-|_)+([a-zA-Z0-9$_])/g fn [i] { i.1.to-upper-case! } }

  @uppercase fn [str] { str.to-upper-case! }

  @stringify fn [& args] { foldl concat args }

  @capitalize fn [str] { (str.0.to-upper-case!) ++ (str.slice 1) }

  @chars fn [f str] { str.split '' | map f }

  @condense fn [str] { str.replace /\ /g '' }

  @lines fn [f str] { str.split '\n' | map f }

  @words fn [f str] { str.split ' ' | map f }

  @print fn [& args] { console.log.apply console args }
}
