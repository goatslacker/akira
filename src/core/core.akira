macro bin-expr fn [op a b] {
  @type 'BinaryExpression'
  @operator op.value
  @left a
  @right b
}

macro each fn [sym name test] {
  @type 'ForInStatement'
  @left {
    @type 'VariableDeclaration'
    @declarations [{
      @type 'VariableDeclarator'
      @id sym
      @init none
    }]
    @kind 'var'
  }
  @right name
  @body {
    @type 'BlockStatement'
    @body [{
      @type 'IfStatement'
      @test test
      @consequent {
        @type 'BlockStatement'
        @body [{
          @type 'ReturnStatement'
          @argument sym
        }]
      }
      @alternate none
    }]
  }
  @each false
}

macro single-if fn [test body] {
  @type 'IfStatement'
  @test test
  @consequent {
    @type 'BlockStatement'
    @body [body]
  }
  @alternate none
}

export {

  @eq (`
    eq = fn [a b] a == b)

  @deep-eq (`
    deep-eq = fn [a b]
      if a.length isnt b.length
        then false
        else if a.length is 0
          then false
          else zip-with: (==) a b | foldl: (&&) | eq: true)

  @neq (`
    neq = fn [a b] a != b)

  @gt (`
    gt = fn [a b] a > b)

  @lt (`
    lt = fn [a b] a < b)

  @gte (`
    gte = fn [a b] a >= b)

  @lte (`
    lte = fn [a b] a <= b)

  @and (`
    and = fn [a b] a && b)

  @or (`
    or = fn [a b] a || b)

  @head (`
    head = fn [[x]] x)

  @init (`
    init = fn [[& xs x]] xs)

  @tail (`
    tail = fn [[x & xs]] xs)

  @last (`
    last = fn [[& xs x]] x)

  @get (`
    get = fn [obj prop] obj !! prop)

  @length (`
    length = fn [of] of.length)

  @join (`
    join = fn [by vec] vec.join: by)

  @concat (`
    concat = fn
      [a] a
      [a b] a ++ b
      [a b c] a ++ b ++ c
      [& a] foldl: (fn [a b] a ++ b) a
  )

  @count (`
    count = fn
      [vec] vec.length
      [vec f] filter: f vec | (.length)
  )

  @zip-with (`
    zip-with = fn [f [a & as] [b & bs]]
      if (a is undefined) || (b is undefined)
        then []
        else (f: a b) +: (zip-with: f as bs))

  @average (`
    average = fn [vec] foldl: (fn [a b] a + b) vec | (/ vec.length))

  @compact (`
    compact = fn [vec] filter: (fn [x] not not x) vec)

  @assert (`
    assert = fn [a b] {
      if a != b
        then {
          raise 'Expected {{a}} == {{b}}'
          false
        }
        else true
    })

  @find (`
    find = fn [f ds] each i ds ((f: ds !! i) is true))

  @call (`
    call = fn [obj prop & args] (obj !! prop) | (.apply: obj, args))

  @keys (`
    keys = Object.keys)

  @values (`
    values = fn [x] map: (fn [k] x !! k) (keys: x))

  @key (`
    key = fn [v x] find: (== v) x)

  @value (`
    value = fn [k x] x !! k)

  @filter (`
    filter = fn [f vec]
      Array.prototype.filter.call: vec (fn [x] f: x))

  @map (`
    map = fn [f vec]
      Array.prototype.map.call: vec (fn [x] f: x))

  @foldl (`
    foldl = fn [f vec]
      if vec.length is 0
        then []
        else Array.prototype.reduce.call: vec (fn [a b] f: a b))

  @foldr (`
    foldr = fn [f vec]
      if vec.length is 0
        then []
        else Array.prototype.reduce-right.call: vec (fn [a b] f: a b))

  @intersect (`
    intersect = fn [vec1 vec2] filter: (fn [x] vec2.indexOf: x | (!= -1)) vec1)

  @max (`
    max = fn [vec] foldl: (fn [a b] if a > b then a else b) vec)

  @min (`
    min = fn [vec] foldl: (fn [a b] if a < b then a else b) vec)

  @nothing (`
    nothing = fn [f vec] filter: f vec | (.length) | (== 0))

  @randomize (`
    randomize = fn [vec] sort: (fn [] (Math.random!) > 0.5) vec)

  @take (`
    take = fn [n vec] vec.slice: 0 n)

  @drop (`
    drop = fn [n vec] vec.slice: n)

  @take-while (`
    take-while = fn [f [x & xs]]
      if (f: x) is true
        then x +: (take-while: f xs)
        else [])

  @apply (`
    apply = fn [f & args] f.apply: f args)

  @id (`
    id = fn [a] a)

  @flip (`
    flip = fn [f a b] f: b a)

  @partial (`
    partial = fn [f & args] fn [& xargs] f.apply: f, args ++ xargs)

  @partialr (`
    partialr = fn [f & args] fn [& xargs] f.apply: f, xargs ++ args)

  @curry (`
    curry = fn [f] {
      l = f.length
      c = fn [args] fn [& arg] {
        xargs = args ++ arg
        if xargs.length < l then c: xargs else f.apply: f, xargs
      }
      if l < 1 then f else c: []
    })

  -- curryr = fn [f] {
  --   c = fn [(args = [])] fn [arg] {
  --     xargs = arg +: args
  --     if xargs.length < f.length then c: xargs else f.apply: f, xargs
  --   }
  --
  --   if f.length < 1 then f else c: none
  -- }

  @when (`
   when = fn [is-true callback] single-if is-true (callback!))

  @show (`
    show = fn [i] i.to-string!)

  @mod (`
    mod = fn [a b] bin-expr '%' a b)

  @bit-and (`
    bit-and = fn [a b] bin-expr '&' a b)

  @bit-or (`
    bit-or = fn [a b] bin-expr '|' a b)

  @bit-xor (`
    bit-xor = fn [a b] bin-expr '^' a b)

  @bit-shiftl (`
    bit-shiftl = fn [a b] bin-expr '<<' a b)

  @bit-shiftr (`
    bit-shiftr = fn [a b] bin-expr '>>' a b)

  @bit-ushiftr (`
    bit-ushiftr = fn [a b] bin-expr '>>>' a b)

  @square (`
    square = fn [x] x * x)

  @sum (`
    sum = fn [a b] a + b)

  @sub (`
    sub = fn [a b] a - b)

  @prod (`
    prod = fn [a b] a * b)

  @div (`
    div = fn [a b] a / b)

  @even (`
    even = fn [n] (bin-expr '%' n 2) | (== 0))

  @odd (`
    odd = fn [n] (bin-expr '%' n 2) | (!= 0))

  @abs (`
    abs = fn [n] Math.abs: n)

  @sqrt (`
    sqrt = fn [n] Math.sqrt: n)

  @pow (`
    pow = fn [a b] Math.pow: a b)

  @inc (`
    inc = fn [x] x + 1)

  @dec (`
    dec = fn [x] x - 1)

  @false? (`
    false? = fn [x] x is false)

  @true? (`
    true? = fn [x] x is true)

  @pos? (`
    pos? = fn [x] x > 0)

  @neg? (`
    neg? = fn [x] x < 0)

  @zero? (`
    zero? = fn [x] x is 0)

  @num? (`
    num? = fn [x] x is Number)

  @str? (`
    str? = fn [x] x is String)

  @map? (`
    map? = fn [x] x is Map)

  @vector? (`
    vector? = fn [x] x is Vector)

  @bool? (`
    bool? = fn [x] x is true || x is false)

  @none? (`
    none? = fn [x] x is none)

  @camelize (`
    camelize = fn [str] str.replace: /(-|_)+([a-zA-Z0-9$_])/g,
      (fn [i] i.2.to-upper-case!))

  @uppercase (`
    uppercase = fn [str] str.to-upper-case!)

  @capitalize (`
    capitalize = fn [str] (str.1.to-upper-case!) ++ (str.slice: 1))

  @chars (`
    chars = fn [f str] str.split: '' | map: f)

  @condense (`
    condense = fn [str] str.replace: /\ /g '')

  @lines (`
    lines = fn [f str] str.split: '\n' | map: f)

  @words (`
    words = fn [f str] str.split: ' ' | map: f)

  @print (`
    print = fn [& args] console.log.apply: console args)
}
