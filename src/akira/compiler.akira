{ @get-files } = import './fisy.akira'

util = require 'util'
escodegen = require 'escodegen'
dune = require 'dune'
lexer = require '../lang/lexer'
parser = require '../lang/grammar'
parser.yy = (require '../lang/nodes')

to-ast = fn [body] {
  {
    @type 'Program'
    @body [{
      @type 'ExpressionStatement'
      @expression {
        @type 'CallExpression'
        @callee {
          @type 'FunctionExpression'
          @id none
          @params []
          @body {
            @type 'BlockStatement'
            @body body
          }
        }
        @arguments []
      }
    }]
  }
}

transform = fn [name parsed (f = to-ast)] {
  cond
    parsed is none ? f ''
    else ? {
      context = {}
      body = parsed.compile context name
      dependencies = parsed.add-deps context
      parsed.flag-core-methods body
      f (parsed.add-vars context) ++
        (parsed.add-core!) ++
        dependencies ++
        (parsed.add-contracts body)
    }
}

parse = fn [code] code | lexer | parser.parse

gen-ast = fn [name code] parse code | transform name

transpile = fn [name code] code | gen-ast name | escodegen.generate

each-file = fn [cb f] {
  fn [name code] {
    try {
      code | f name | cb name
    } catch err {
      util.error 'Filename ' ++ name
      util.error err.stack
      process.exit 1
    }
  }
}

foreach-file = fn [cb filepath (f = transpile)]
  get-files (each-file cb f) filepath

run = fn [name code context] {
  try {
    dune.string code name context
  } catch err {
    util.error name
    util.error err.stack
    none
  }
}

export {
  @foreach-file
  @gen-ast
  @lexer
  @run
}
