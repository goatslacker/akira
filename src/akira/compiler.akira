escodegen = require 'escodegen'
dune = require 'dune'
lexer = require '../lang/lexer'
parser = require '../lang/grammar'
parser.yy = (require '../lang/nodes')
me = require '../../package.json'

HEADER = ' Generated by Akira v' ++ me.version
OPTIONS = {
  @format {
    @indent {
      @style '  '
      @base 0
    }
  }
  @comment true
  @directive true
}

make-program = fn [body] {
  {
    @type 'Program'
    @body [{
      @type 'ExpressionStatement'
      @expression {
        @type 'CallExpression'
        @callee {
          @type 'FunctionExpression'
          @id none
          @params []
          @body {
            @type 'BlockStatement'
            @body body
          }
        }
        @arguments []
      }
      @leading-comments [{
        @type 'Line',
        @value HEADER
      }]
    }]
  }
}

transform = fn [name parsed] {
  cond
    parsed is none ? make-program ''
    else ? {
      context = {}
      body = parsed.compile context name
      dependencies = parsed.add-deps context
      parsed.flag-core-methods body
      make-program (parsed.add-vars context) ++
        (parsed.add-core!) ++
        dependencies ++
        (parsed.add-contracts body)
    }
}

gen-program-ast = fn [name code] {
  lexer code | parser.parse | transform name
}

transpile = fn [name code] {
  escodegen.generate (gen-program-ast name code) OPTIONS
}

run = fn [name code context] {
  try {
    dune.string code name context
  } catch err {
    console.error name
    console.error err.stack
    none
  }
}

export {
  @gen-program-ast
  @lexer
  @run
  @transpile
}
