CallExpression = require 'ast/CallExpression'
ExpressionStatement = require 'ast/ExpressionStatement'
Identifier = require 'ast/Identifier'
MemberExpression = require 'ast/MemberExpression'
Store = require 'Store'
TypeSystem = require 'TypeSystem'
ast = require 'ast'
escodegen = require 'escodegen'
esprima = require 'esprima'
obj2str = require 'obj2str'
unwrapExpressionStatement = require 'unwrapExpressionStatement'
vm = require 'vm'

run-macro = fn [name xargs context]
  let
    ast = Store.macros !! name
    args = obj2str xargs | esprima.parse
    code = CallExpression ast args.body.0.expression.elements | ExpressionStatement | escodegen.generate
  then vm.run-in-new-context code context

checkCallType = fn [name params context line] {
  type = Store.types !! name
  if type then {
    tparams = type.params
    if tparams && params then {
      params-unbalanced = tparams.length != params.length
      if params-unbalanced is true
        then console.warn '{{name}} was signed with {{tparams.length}} ' ++
          'arguments yet it was provided with {{params.length}} ' ++
          'at {{context.$$$filename}} line {{line}}'
        else none
    } else none
  } else none
}

unwrap = fn [xargs] {
  (map unwrapExpressionStatement xargs) if xargs
}

return-function = fn [callee args params context line] {
  checkCallType callee.name args context line

  if args && args.__rest is true
    then CallExpression (MemberExpression callee (Identifier 'apply')) [(Identifier 'null') args]
    else if params == 'apply'
      then CallExpression (MemberExpression callee (Identifier 'apply')) [(Identifier 'null') (Identifier 'arguments')]
      else CallExpression callee (unwrap args)
}

Call = class {
  [@ref @params] { this }

  compile [context] {
    callee = ast this.ref context
    args = ast this.params context

    if callee.type == 'Identifier' && Store.macros !! callee.name
      then run-macro callee.name args context
      else return-function callee args this.params context this.line
  }
}

module.exports = Call
