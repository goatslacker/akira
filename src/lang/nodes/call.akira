CallExpression = require 'ast/CallExpression'
ExpressionStatement = require 'ast/ExpressionStatement'
Identifier = require 'ast/Identifier'
MemberExpression = require 'ast/MemberExpression'
Store = require 'Store'
TypeSystem = require 'TypeSystem'
ast = require 'ast'
escodegen = require 'escodegen'
esprima = require 'esprima'
obj2str = require 'obj2str'
unwrapExpressionStatement = require 'unwrapExpressionStatement'
vm = require 'vm'

run-macro = fn [name xargs context]
  let
    ast = Store.macros !! name
    args = obj2str xargs | esprima.parse
    code = CallExpression ast args.body.1.expression.elements | ExpressionStatement | escodegen.generate
  then vm.run-in-new-context code context

checkCallType = fn [name params context line] {
  let params-unbalanced = maybe {
    type = Store.types !! name
    tparams = type.params
    tparams.length != params.length
  }
  then if params-unbalanced is true
    then console.warn '{{name}} was signed with {{tparams.length}} ' ++
      'arguments yet it was provided with {{params.length}} ' ++
      'at {{context.$$$filename}} line {{line}}'
    else none
}

unwrap = fn [xargs]
  maybe {
    map unwrapExpressionStatement xargs
  }

return-function = fn [callee args params context line] {
  checkCallType callee.name args context line

  if params == 'apply'
  then CallExpression (MemberExpression callee (Identifier 'apply')) [(Identifier 'null') (Identifier 'arguments')]
  else CallExpression callee (unwrap args)
}

call = fn [ref params]
  fn [line context] {
    compile = ast.gen context
    callee = compile ref
    args = compile params

    if callee.type == 'Identifier' && Store.macros !! callee.name
      then run-macro callee.name (compile params) context
      else return-function callee args params context line
  }

export *call
