CallExpression = require 'ast/CallExpression'
ExpressionStatement = require 'ast/ExpressionStatement'
Identifier = require 'ast/Identifier'
MemberExpression = require 'ast/MemberExpression'
Store = require 'Store'
TypeSystem = require 'TypeSystem'
ast = require 'ast'
escodegen = require 'escodegen'
esprima = require 'esprima'
obj2str = require 'obj2str'
unwrapExpressionStatement = require 'unwrapExpressionStatement'
vm = require 'vm'

run-macro = fn [name xargs context] {
  ast = Store.macros !! name
  args = obj2str xargs | esprima.parse
  elements = args.body.0.expression.elements || []
  code = CallExpression ast elements | ExpressionStatement | escodegen.generate
  scope = copy (copy {} context) this
  vm.run-in-new-context code scope
}

type-check-params = fn [inferred actual context line name] {
  combined = zip-with fn [a b] {
    if a is none || b is none
      then true
      else a == b
  } inferred actual
  matched = foldl (&&) combined true

  (raise '{{name}} was provided with an incorrect parameter ' ++
    'at {{context.$$$filename}} line {{line}}' TypeError) if not matched
}

checkCallType = fn [name (params = []) context line] {
  type = Store.types !! name
  if type then {
    inferred-params = map (-> TypeSystem.infer &0 context) params
    akira-param-types = if type.params
      then map TypeSystem.convert-akira-type type.params
      else []
    (type-check-params inferred-params,
      akira-param-types,
      context,
      line,
      name) if akira-param-types.length && inferred-params.length

    tparams = type.params
    if tparams && params then {
      params-unbalanced = tparams.length != params.length
      if params-unbalanced is true
        then console.warn '{{name}} was signed with {{tparams.length}} ' ++
          'arguments yet it was provided with {{params.length}} ' ++
          'at {{context.$$$filename}} line {{line}}'
        else none
    } else none
  } else none
}

unwrap = fn [xargs] {
  (map unwrapExpressionStatement xargs) if xargs
}

return-function = fn [callee args params context line] {
  checkCallType callee.name args context line

  if args && args.__rest is true
    then CallExpression (MemberExpression callee (Identifier 'apply')) [(Identifier 'null') args]
    else if params == 'apply'
      then CallExpression (MemberExpression callee (Identifier 'apply')) [(Identifier 'null') (Identifier 'arguments')]
      else CallExpression callee (unwrap args)
}

check-callee-type = fn [node] {
  if node.type == 'Literal'
    then raise 'Cannot call using a Literal' TypeError
    else none
}

Call = class {
  [@ref @params] { this }

  compile [context] {
    callee = ast this.ref context
    args = ast this.params context

    check-callee-type callee

    if callee.type == 'Identifier' && Store.macros !! callee.name
      then run-macro callee.name args context
      else return-function callee args this.params context this.line
  }
}

module.exports = Call
