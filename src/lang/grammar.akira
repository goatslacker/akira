jison = require 'jison'

unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*)\s*\}/

macro jsnew fn [name & args] {
  { @type 'NewExpression'
    @callee name
    @arguments args }
}

macro new fn [name & args] {
  { @type 'CallExpression'
    @callee {
      @type 'MemberExpression'
      @computed false
      @object { @type 'Identifier' @name 'yy' }
      @property { @type 'Identifier' @name 'L' }
    }
    @arguments [
      { @type 'Identifier' @name 'yylineno' }
      { @type 'NewExpression'
        @callee {
          @type 'MemberExpression'
          @computed false
          @object { @type 'Identifier' @name 'yy' }
          @property name
        }
        @arguments args
      }
    ]
  }
}

get-match = fn [action] {
  x = unwrap.exec action
  if x then x.2 else '({{action}}())'
}

o = fn [pattern action] {
  pattern-string = pattern.replace /\s{2,}/g, ' '
  if not action
    then [pattern-string '$$ = $1']
    else {
      newaction = action | get-match
      [pattern-string '$$ = {{newaction}}']
    }
}

start-symbol = 'Root'

bnf = {
  @Root [
    ['' 'return $$ = new yy.Nodes;']
    ['Program' 'return $$ = $1']
  ]

  @Program [
    (o 'Terminator Statements' (= $2))
    (o 'Terminator' (= none))
    (o 'Statements')
  ]

  @Statements [
    (o 'Body' (-> yy.Nodes.wrap $1))
    (o 'Statements TERMINATOR Body' (-> $1.push $3))
    (o 'Statements ; Body' (-> $1.push $3))
    (o 'Statements TERMINATOR')
  ]

  @Terminator [
    (o 'TERMINATOR')
    (o 'Terminator TERMINATOR')
  ]

  @OptTerminator [
    (o '')
    (o 'Terminator')
  ]

  @Identifier [
    (o 'IDENTIFIER' (-> new Identifier $1))
  ]

  @Prototype [
    (o 'PROTOTYPE' (-> new Identifier '__prototype'))
  ]

  @Rest [
    (o '& IDENTIFIER' (-> new Identifier $2 true))
  ]

  @TBody [
    (o '{ OptTerminator Statements }' (-> $3))
  ]

  @Body [
    (o 'TBody')
    (o 'Statement')
  ]

  @Statement [
    (o 'Exporting')
    (o 'Expression')
    (o 'Recur')
    (o 'DefMacro')
    (o 'TypeSignature')
    (o 'Modules')
    (o 'Class')
  ]

  @Expression [
    (o 'Value')
    (o 'If')
    (o 'Assignment')
    (o 'PatternMatching')
    (o 'Cond')
    (o 'Invocation')
    (o 'InlineDeclaration')
    (o 'AsyncDo')
    (o 'MaybeSeq')
    (o 'Let')
    (o 'Pipeline')
    (o 'Cloning')
    (o 'Macro')
    (o 'Raise')
    (o 'Exceptions')
    (o 'IMPORT STR' (-> new Import $2))
  ]

  @Value [
    (o 'Accessibles')
    (o 'Operation')
  ]

  @Callable [
    (o 'Identifier')
    (o 'Declaration')
    (o 'ArgumentsShorthand')
    (o 'Access')
  ]

  @Accessibles [
    (o 'Callable')
    (o 'Literal')
    (o 'Vectors')
    (o 'Maps')
    (o 'Type')
    (o 'Prototype')
    (o 'SpecialFunctions')
    (o 'ArgumentsShorthand ^ Identifier' (-> new Assignment $3 $1))
    (o '( OptTerminator Expression OptTerminator )' (-> $3))
  ]

  @ArgumentsShorthand [
    (o 'ARGS' (-> 'arguments[{{$1}}]'))
  ]

  @Literal [
    (o 'AlphaNumeric')
    (o 'NONE' (-> new Literal none))
    (o 'BOOL' (-> new Literal ($1 is 'true')))
    (o 'REGEXP' (-> new Literal $1))
  ]

  @AlphaNumeric [
    (o 'NUM' (-> new Literal (Number ($1.replace /,/g, ''))))
    (o 'Strings')
  ]

  @Strings [
    (o 'STR' (-> new Literal (String $1)))
  ]

  @Assignment [
    (o 'Identifier = Expression' (-> new Assignment $1 $3))
    (o 'Access = Expression' (-> new Assignment $1 $3))
    (o 'Vectors = Expression' (-> new Assignment $1 $3))
    (o 'Maps = Expression' (-> new Assignment $1 $3))
  ]

  @Modules [
    (o 'MODULE STR Body' (-> new Modules $2 $3))
  ]

  @Exporting [
    (o 'EXPORT Expression' (-> new Export $2 false))
    (o 'EXPORT * Expression' (-> new Export $3 true))
  ]

  @Cloning [
    (o 'Identifier : Arguments' (-> new Cloning $3 $1))
    (o 'Maps Arguments' (-> new Cloning $2 $1))
    (o 'Vectors Arguments' (-> new Cloning $2 $1))
  ]

  @CallableValue [
    (o 'Value')
    (o 'Invocation')
  ]

  @Pipeline [
    (o 'Value | OptTerminator CallableValue' (-> new Pipeline $1 $4))
    (o 'Invocation | OptTerminator CallableValue' (-> new Pipeline $1 $4))
    (o 'Pipeline | OptTerminator CallableValue' (-> new Pipeline $1 $4))
  ]

  @Invocation [
    (o 'Callable Arguments' (-> new Call $1 $2))
    (o 'Callable !' (-> new Call $1))
    (o 'Callable & !' (-> new Call $1, 'apply'))
  ]

  @Declaration [
    (o 'FN [ Parameters ] TBody' (-> new Declaration none $3 $5))
    (o 'FN [ ] TBody' (-> new Declaration none none $4))
    (o 'LAMBDA TBody' (-> new Declaration none none $2))
  ]

  @InlineDeclaration [
    (o 'FN [ Parameters ] Expression' (-> new Declaration none $3 $5))
    (o 'FN [ Parameters ] TERMINATOR Expression' (-> new Declaration none $3 $6))
    (o 'FN [ ] Expression' (-> new Declaration none none $4))
    (o 'LAMBDA Expression' (-> new Declaration none none $2))
  ]

  @LetOperation [
    (o 'Assignment Terminator')
  ]

  @LetOperations [
    (o 'LetOperation' (-> new Arguments $1))
    (o 'LetOperations LetOperation' (-> new Arguments $1 $2))
  ]

  @Let [
    (o 'LET OptTerminator LetOperations THEN OptTerminator Expression TERMINATOR' (-> new Let $3 $6))
  ]

  @MaybeParameters [
    (o 'Value' (-> new Arguments $1))
    (o 'MaybeParameters OptComma Value' (-> new Arguments $1 $3))
  ]

  @MaybeSeq [
    (o 'MAYBE [ MaybeParameters ] TBody' (-> new MaybeSeq $5 $3))
    (o 'MAYBE TBody' (-> new MaybeSeq $2))
  ]

  @DoOperation [
    (o 'Vectors DO_OPERATOR Value TERMINATOR' (-> { @args $1 @call $3 }))
    (o 'Expression TERMINATOR' (-> { @expr $1 }))
  ]

  @DoOperations [
    (o 'DoOperation' (-> new Arguments $1))
    (o 'DoOperations DoOperation' (-> new Arguments $1 $2))
  ]

  @AsyncDo [
    (o 'DO [ Parameters ] Terminator DoOperations' (-> new Async $6 $3))
    (o 'DO Terminator DoOperations' (-> new Async $3 none))
  ]

  @Conditional [
    (o 'Value ? Body Terminator' (-> [$1 $3]))
  ]

  @Conditionals [
    (o 'Conditional' (-> new Arguments $1))
    (o 'Conditionals Conditional' (-> new Arguments $1 $2))
  ]

  @CondElse [
    (o 'ELSE ? Body' (-> [$1 $3]))
  ]

  @Cond [
    (o 'COND TERMINATOR Conditionals CondElse' (-> new Cond $3 $4))
  ]

  @Pattern [
    (o '[ ] Body TERMINATOR' (-> [none $3]))
    (o '[ VectorArgs ] Body TERMINATOR' (-> [$2 $4]))
    (o '[ ELSE ] Body TERMINATOR' (-> [$2 $4]))
  ]

  @Patterns [
    (o 'Pattern' (-> new Arguments $1))
    (o 'Patterns Pattern' (-> new Arguments $1 $2))
  ]

  @PatternMatching [
    (o 'MATCH { OptTerminator Patterns }' (-> new Pattern $4))
  ]

  @Comma [
    (o '')
    (o ', OptTerminator')
  ]

  @Vectors [
    (o '[ ]' (-> new Vector))
    (o '[ OptTerminator VectorArgs OptTerminator ]' (-> new Vector $3))
  ]

  @VectorArg [
    (o 'Value')
    (o 'Rest')
  ]

  @VectorArgs [
    (o 'VectorArg' (-> new Arguments $1))
    (o 'VectorArgs OptComma VectorArg' (-> new Arguments $1 $3))
  ]

  @Key [
    (o 'KEY' (-> new Identifier $1))
  ]

  @KeyValue [
    (o 'Key' (-> new Assignment $1 none))
    (o 'Key Value' (-> new Assignment $1 $2))
  ]

  @MapItems [
    (o 'KeyValue' (-> new Arguments $1))
    (o 'MapItems OptComma KeyValue' (-> new Arguments $1 $3))
  ]

  @Class [
    (o 'CLASS Identifier TypeValues',
      (-> new Class (new TypeSignature $2 '' $3)))
  ]

  @Maps [
    (o '{ }' (-> new Map))
    (o '{ OptTerminator MapItems OptTerminator }' (-> new Map $3))
  ]

  @Access [
    (o 'Accessibles Accessor' (-> new Access $1 $2))
  ]

  @Accessor [
    (o '. Identifier' (-> $2))
    (o '. Literal' (-> $2))
    (o '. PROTOTYPE' (-> $2))
  ]

  @Arguments [
    (o 'Value' (-> new Arguments $1))
    (o 'Arguments Comma Value' (-> new Arguments $1 $3))
  ]

  @Param [
    (o 'Identifier')
    (o '( Identifier = Value )' (-> new Assignment $2 $4))
    (o 'Rest')
    (o 'Vectors')
  ]

  @OptComma [
    (o ', OptTerminator')
    (o 'OptTerminator')
  ]

  @Parameters [
    (o 'Param' (-> new Arguments $1))
    (o 'Parameters OptComma Param' (-> new Arguments $1 $3))
  ]

  @Exceptions [
    (o 'TRY Body OptTerminator CATCH Identifier Body' (-> new ExceptionGuard $2 $5 $6))
  ]

  @Raise [
    (o 'RAISE Value ErrorType' (-> new Exception $1 $2 $3))
  ]

  @ErrorType [
    (o '' (-> none))
    (o 'Identifier')
  ]

  @Recur [
    (o 'RECUR OptTerminator Arguments' (-> new Recur $3))
    (o '( RECUR OptTerminator Arguments )' (-> new Recur $4))
  ]

  @If [
    (o 'IF CallableValue OptTerminator THEN Body OptTerminator ELSE Body',
      (-> new If $2 $5 $8))
  ]

  @DefMacro [
    (o 'MACRO Identifier Declaration' (-> new Macro $2 $3))
  ]

  @TypeValues [
    (o 'Identifier')
    (o 'VectorType')
    (o 'MapType')
    (o 'MAYBE TypeValues' (-> new Type $2 'maybe'))
  ]

  @TypeValue [
    (o 'TypeValues')
    (o 'TypeValues | TypeValue' (-> new Type [$1 $3] 'or'))
  ]

  @VectorType [
    (o '[ TypeParams ]' (-> new Type $2 'vector'))
  ]

  @MapType [
    (o '{ OptTerminator MapTypeParams OptTerminator }' (-> new Type $3 'map'))
  ]

  @MaybeTypeParams [
    (o '')
    (o 'TypeParams')
  ]

  @TypeKeyValue [
    (o 'Key' (-> new Assignment $1 none))
    (o 'Key TypeValue' (-> new Assignment $1 $2))
  ]

  @MapTypeParams [
    (o 'TypeKeyValue' (-> new Arguments $1))
    (o 'MapTypeParams TypeKeyValue' (-> new Arguments $1 $2))
  ]

  @TypeParams [
    (o 'TypeValue' (-> new Arguments $1))
    (o 'TypeParams TypeValue' (-> new Arguments $1 $2))
  ]

  @TypeSignature [
    (o 'Identifier TYPE_OPERATOR MaybeTypeParams LAMBDA TypeValue',
      (-> new TypeSignature $1 $3 $5))
  ]

  @Macro [
    (o '` OptTerminator Statement' (-> new Evaluate $3))
    (o '~ OptTerminator Statement' (-> new Evaluate $3 true))
  ]

  @Operators [
    (o '+' (-> new Identifier 'sum'))
    (o '-' (-> new Identifier 'sub'))
    (o '*' (-> new Identifier 'prod'))
    (o '* *' (-> new Identifier 'pow'))
    (o '/' (-> new Identifier 'div'))
    (o 'COMPARE' (-> new Compare $1))
    (o 'LOGIC' (-> new Logic $1))
  ]

  @SugaryFunctions [
    (o 'Operators' (-> $1))
    (o 'Accessor',
      (-> new Declaration '->' (new Arguments 'it'),
        (new Access 'it' $1)))
    (o 'Accessor Arguments',
      (-> new Declaration '->' (new Arguments 'it'),
        (new Call (new Access 'it' $1) $2)))
    (o 'COMPARE Value',
      (-> new Declaration '->' (new Arguments 'it'),
        (new Compare 'it' $1 $2)))
    (o 'LEFT_OPERATORS Value',
      (-> new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o '= Value' (-> new Declaration '->' (new Arguments 'it') $2))
    (o '+ Value',
      (-> new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o '- Value',
      (-> new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o '* Value',
      (-> new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o '* * Value',
      (-> new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' '**' $3)))
    (o '/ Value',
      (-> new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
  ]

  @SpecialFunctions [
    (o '( SugaryFunctions )' (-> $2))
  ]

  @Operation [
    (o 'Value COMPARE OptTerminator Value' (-> new Compare $1 $2 $4))
    (o 'Value LOGIC OptTerminator Value' (-> new Logic $1 $2 $4))
    (o 'Value LEFT_OPERATORS OptTerminator Value',
      (-> new Operation $1 $2 $4))
    (o 'Value RIGHT_OPERATORS OptTerminator Value',
      (-> new Operation $1 $2 $4))
    (o 'NOT Value' (-> new Compare $2 $1))
    (o 'Value + OptTerminator Value' (-> new Operation $1 '+' $4))
    (o 'Value - OptTerminator Value' (-> new Operation $1 '-' $4))
    (o 'Value * OptTerminator Value' (-> new Operation $1 '*' $4))
    (o 'Value * * OptTerminator Value' (-> new Operation $1 '**' $5))
    (o 'Value / OptTerminator Value' (-> new Operation $1 '/' $4))
  ]
}


tokens = [
  'ASSERT' 'IF' 'THEN' 'ELSE'
  'FN' 'MATCH' 'KEY' 'LAMBDA'
  'IDENTIFIER' 'BOOL' 'NUM' 'STR'
  'LOGIC' 'COMPARE' 'DO' 'RETURN'
  'TERMINATOR'
]

operators = [
  ['right' 'NOT']
  ['right' 'IF' 'THEN' 'ELSE' 'IMPORT' 'EXPORT']
  ['right' '=' '|']
  ['right' 'RIGHT_OPERATORS']
  ['nonassoc' '(' ')' '[' ']' '{' '}' ':']
  ['left' 'LOGIC']
  ['left' 'COMPARE']
  ['left' 'LEFT_OPERATORS']
  ['left' '+' '-']
  ['left' '*' '**' '/']
]

parser = jsnew jison.Parser { @tokens @bnf @operators @start-symbol }
parser.lexer = {
  @lex (fn [] {
    ref = this.tokens !! this.pos || ['']
    this.pos = this.pos + 1
    this.yytext = ref !! 1
    this.yylineno = ref !! 2
    ref !! 0
  })

  @set-input (fn [tokens] {
    this.tokens = tokens
    this.pos = 0
  })
}

export *parser
