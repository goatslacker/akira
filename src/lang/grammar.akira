jison = require: 'jison'

unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*)\s*\}/

macro new fn [name & args] {
  { @type 'NewExpression'
  @callee name
  @arguments args }
}

get-match = fn [action] {
  x = unwrap.exec: action
  if x then x.2 else '({{action}}())'
}

addYY = fn [str] { str.replace: /new /g, 'new yy.' }
add-line = fn [str] { 'yy.L(yylineno, ' ++ (str.replace: ';', '') ++ ');' }

o = fn [pattern action] {
  pattern-string = pattern.replace: /\s{2,}/g, ' '
  if not action
    then [pattern-string '$$ = $1']
    else {
      newaction = action | get-match | addYY | add-line
      [pattern-string '$$ = {{newaction}}']
    }
}

start-symbol = 'Root'

bnf = {
  @Root [
    ['' 'return $$ = new yy.Nodes;']
    ['Program' 'return $$ = $1']
  ]

  @Program [
    (o: 'Terminator Statements' (= $2))
    (o: 'Terminator' (= none))
    (o: 'Statements')
  ]

  @Statements [
    (o: 'Body' -> (yy.Nodes.wrap: $1))
    (o: 'Statements TERMINATOR Body' -> ($1.push: $3))
    (o: 'Statements ; Body' -> ($1.push: $3))
    (o: 'Statements TERMINATOR')
  ]

  @Terminator [
    (o: 'TERMINATOR')
    (o: 'Terminator TERMINATOR')
  ]

  @OptTerminator [
    (o: '')
    (o: 'Terminator')
  ]

  @Identifier [
    (o: 'IDENTIFIER' -> (new Identifier $1))
  ]

  @Prototype [
    (o: 'PROTOTYPE' -> (new Identifier '__prototype'))
  ]

  @Rest [
    (o: '& IDENTIFIER' -> (new Identifier $2 true))
  ]

  @TBody [
    (o: '{ OptTerminator Statements }' -> ($3))
  ]

  @Body [
    (o: 'TBody')
    (o: 'Statement')
  ]

  @Statement [
    (o: 'Exporting')
    (o: 'Expression')
    (o: 'Exceptions')
    (o: 'Recur')
    (o: 'DefMacro')
    (o: 'TypeSignature')
  ]

  @Expression [
    (o: 'Value')
    (o: 'If')
    (o: 'Assignment')
    (o: 'PatternMatching')
    (o: 'Cond')
    (o: 'Invocation')
    (o: 'InlineDeclaration')
    (o: 'AsyncDo')
    (o: 'MaybeSeq')
    (o: 'Let')
    (o: 'Pipeline')
    (o: 'Cloning')
    (o: 'Macro')
    (o: 'Raise')
    (o: 'IMPORT STR' -> (new Import $2))
  ]

  @Value [
    (o: 'Values')
    (o: 'AnonymousFunction')
    (o: 'Declaration')
    (o: 'Access')
    (o: 'Operation')
  ]

  @Values [
    (o: 'Literal')
    (o: 'Vectors')
    (o: 'Maps')
    (o: 'Type')
    (o: 'Prototype')
    (o: 'SpecialFunctions')
    (o: 'ArgumentsShorthand')
    (o: 'ArgumentsShorthand ^ Identifier' -> (new Assignment $3 $1))
    (o: '( OptTerminator Expression OptTerminator )' -> ($3))
  ]

  @ArgumentsShorthand [
    (o: 'ARGS' -> ('arguments[{{$1}}]'))
  ]

  @CallableValue [
    (o: 'Value')
    (o: 'Invocation')
  ]

  @Literal [
    (o: 'Identifier')
    (o: 'AlphaNumeric')
    (o: 'NONE' -> (new Literal none))
    (o: 'BOOL' -> (new Literal ($1 is 'true')))
    (o: 'REGEXP' -> (new Literal $1))
  ]

  @AlphaNumeric [
    (o: 'NUM' -> (new Literal (Number: ($1.replace: /,/g, ''))))
    (o: 'Strings')
  ]

  @Strings [
    (o: 'STR' -> (new Literal (String: $1)))
  ]

  @Assignment [
    (o: 'Identifier = Expression' -> (new Assignment $1 $3))
    (o: 'Access = Expression' -> (new Assignment $1 $3))
    (o: 'Vectors = Expression' -> (new Assignment $1 $3))
    (o: 'Maps = Expression' -> (new Assignment $1 $3))
  ]

  @Exporting [
    (o: 'EXPORT Expression' -> (new Export $2))
  ]

  @Cloning [
    -- Identifier Arguments also handles @Macro
    (o: 'Identifier Arguments' -> (new Cloning $2 $1))
    (o: 'Maps Arguments' -> (new Cloning $2 $1))
    (o: 'Vectors Arguments' -> (new Cloning $2 $1))
  ]

  @Pipeline [
    (o: 'Value | OptTerminator CallableValue' -> (new Pipeline $1 $4))
    (o: 'Invocation | OptTerminator CallableValue' -> (new Pipeline $1 $4))
    (o: 'Pipeline | OptTerminator CallableValue' -> (new Pipeline $1 $4))
  ]

  @Invocation [
    (o: 'Value : Arguments' -> (new Call $1 $3))
    (o: 'Value !' -> (new Call $1))
    (o: 'Value & !' -> (new Call $1, 'apply'))
  ]

  @Declaration [
    (o: 'FN [ Parameters ] TBody' -> (new Declaration none $3 $5))
    (o: 'FN [ ] TBody' -> (new Declaration none none $4))
  ]

  @InlineDeclaration [
    (o: 'FN [ Parameters ] Expression' -> (new Declaration none $3 $5))
    (o: 'FN [ Parameters ] TERMINATOR Expression' -> (new Declaration none $3 $6))
    (o: 'FN [ ] Expression' -> (new Declaration none none $4))
  ]

  @LetOperation [
    (o: 'Assignment Terminator')
  ]

  @LetOperations [
    (o: 'LetOperation' -> (new Arguments $1))
    (o: 'LetOperations LetOperation' -> (new Arguments $1 $2))
  ]

  @Let [
    (o: 'LET OptTerminator LetOperations THEN OptTerminator Expression TERMINATOR' -> (new Let $3 $6))
  ]

  @MaybeOperation [
    (o: 'Identifier DO_OPERATOR Value TERMINATOR' -> (new Assignment $1 $3))
    (o: 'Expression TERMINATOR' -> ({ @expr $1 }))
  ]

  @MaybeOperations [
    (o: 'MaybeOperation' -> (new Arguments $1))
    (o: 'MaybeOperations MaybeOperation' -> (new Arguments $1 $2))
  ]

  @MaybeSeq [
    (o: 'MAYBE Terminator MaybeOperations' -> (new MaybeSeq $3))
  ]

  @DoOperation [
    (o: 'Vectors DO_OPERATOR RETURN Value TERMINATOR' -> ({ @args $1 @call $4 @is-return true }))
    (o: 'Vectors DO_OPERATOR Invocation TERMINATOR' -> ({ @args $1 @call $3 }))
    (o: 'Expression TERMINATOR' -> ({ @expr $1 }))
  ]

  @DoOperations [
    (o: 'DoOperation' -> (new Arguments $1))
    (o: 'DoOperations DoOperation' -> (new Arguments $1 $2))
  ]

  @AsyncDo [
    (o: 'DO [ Parameters ] Terminator DoOperations' -> (new Async $6 $3))
    (o: 'DO Terminator DoOperations' -> (new Async $3 none))
  ]

  @AnonymousFunction [
    (o: 'LAMBDA ( Expression )' -> (new Declaration none none $3))
  ]

  @Conditional [
    (o: 'Value ? Body Terminator' -> ([$1 $3]))
  ]

  @Conditionals [
    (o: 'Conditional' -> (new Arguments $1))
    (o: 'Conditionals Conditional' -> (new Arguments $1 $2))
  ]

  @CondElse [
    (o: 'ELSE ? Body' -> ([$1 $3]))
  ]

  @Cond [
    (o: 'COND TERMINATOR Conditionals CondElse' -> (new Cond $3 $4))
  ]

  @Pattern [
    (o: '[ ] Body TERMINATOR' -> ([none $3] ))
    (o: '[ VectorArgs ] Body TERMINATOR' -> ([$2 $4] ))
    (o: '[ ELSE ] Body TERMINATOR' -> ([$2 $4] ))
  ]

  @Patterns [
    (o: 'Pattern' -> (new Arguments $1))
    (o: 'Patterns Pattern' -> (new Arguments $1 $2))
  ]

  @PatternMatching [
    (o: 'MATCH { OptTerminator Patterns }' -> (new Pattern $4))
  ]

  @Comma [
    (o: '')
    (o: ', OptTerminator')
  ]

  @Vectors [
    (o: '[ ]' -> (new Vector))
    (o: '[ OptTerminator VectorArgs OptTerminator ]' -> (new Vector $3))
  ]

  @VectorArg [
    (o: 'Value')
    (o: 'Rest')
  ]

  @VectorArgs [
    (o: 'VectorArg' -> (new Arguments $1))
    (o: 'VectorArgs OptComma VectorArg' -> (new Arguments $1 $3))
  ]

  @Key [
    (o: 'KEY' -> (new Identifier $1))
  ]

  @KeyValue [
    (o: 'Key' -> (new Assignment $1 none))
    (o: 'Key Value' -> (new Assignment $1 $2))
  ]

  @MapItems [
    (o: 'KeyValue' -> (new Arguments $1))
    (o: 'MapItems OptComma KeyValue' -> (new Arguments $1 $3))
  ]

  @Maps [
    (o: '{ }' -> (new Map))
    (o: '{ OptTerminator MapItems OptTerminator }' -> (new Map $3))
  ]

  @Access [
    (o: 'Values Accessor' -> (new Access $1 $2))
    (o: 'Access Accessor' -> (new Access $1 $2))
  ]

  @Accessor [
    (o: '. Literal' -> ($2))
    (o: '. PROTOTYPE' -> ($2))
  ]

  @Arguments [
    (o: 'Value' -> (new Arguments $1))
    (o: 'Arguments Comma Value' -> (new Arguments $1 $3))
  ]

  @Param [
    (o: 'Identifier')
    (o: '( Identifier = Value )' -> (new Assignment $2 $4))
    (o: 'Rest')
    (o: 'Vectors')
  ]

  @OptComma [
    (o: ', OptTerminator')
    (o: 'OptTerminator')
  ]

  @Parameters [
    (o: 'Param' -> (new Arguments $1))
    (o: 'Parameters OptComma Param' -> (new Arguments $1 $3))
  ]

  @Exceptions [
    (o: 'TRY Body OptTerminator CATCH Identifier Body' -> (new ExceptionGuard $2 $5 $6))
  ]

  @Raise [
    (o: 'RAISE Value ErrorType' -> (new Exception $1 $2 $3))
  ]

  @ErrorType [
    (o: '' -> (none))
    (o: 'Identifier')
  ]

  @Recur [
    (o: 'RECUR OptTerminator Arguments' -> (new Recur $3))
    (o: '( RECUR OptTerminator Arguments )' -> (new Recur $4))
  ]

  @If [
    (o: 'IF CallableValue OptTerminator THEN Body OptTerminator ELSE Body',
      -> (new If $2 $5 $8))
  ]

  @DefMacro [
    (o: 'MACRO Identifier Declaration' -> (new Macro $2 $3))
  ]

  @TypeValues [
    (o: 'Identifier')
    (o: 'VectorType')
    (o: 'MapType')
    (o: 'MAYBE TypeValues' -> (new Type $2 'maybe'))
  ]

  @TypeValue [
    (o: 'TypeValues')
    (o: 'TypeValues | TypeValue' -> (new Type [$1 $3] 'or'))
  ]

  @VectorType [
    (o: '[ TypeParams ]' -> (new Type $2 'vector'))
  ]

  @MapType [
    (o: '{ MapTypeParams }' -> (new Type $2 'map'))
  ]

  @MaybeTypeParams [
    (o: '')
    (o: 'TypeParams')
  ]

  @TypeKeyValue [
    (o: 'Key' -> (new Assignment $1 none))
    (o: 'Key TypeValue' -> (new Assignment $1 $2))
  ]

  @MapTypeParams [
    (o: 'TypeKeyValue' -> (new Arguments $1))
    (o: 'MapTypeParams TypeKeyValue' -> (new Arguments $1 $2))
  ]

  @TypeParams [
    (o: 'TypeValue' -> (new Arguments $1))
    (o: 'TypeParams TypeValue' -> (new Arguments $1 $2))
  ]

  @TypeSignature [
    (o: 'Identifier TYPE_OPERATOR MaybeTypeParams LAMBDA TypeValue',
      -> (new TypeSignature $1 $3 $5))
  ]

  @Macro [
    (o: '` OptTerminator Statement' -> (new Evaluate $3))
    (o: '~ OptTerminator Statement' -> (new Evaluate $3 true))
  ]

  @Operators [
    (o: '+' -> (new Identifier 'sum'))
    (o: '-' -> (new Identifier 'sub'))
    (o: '*' -> (new Identifier 'prod'))
    (o: '* *' -> (new Identifier 'pow'))
    (o: '/' -> (new Identifier 'div'))
    (o: 'COMPARE' -> (new Compare $1))
    (o: 'LOGIC' -> (new Logic $1))

  ]

  @SugaryFunctions [
    (o: 'Operators' -> ($1))
    (o: 'Accessor',
      -> (new Declaration '->' (new Arguments 'it'),
        (new Access 'it' $1)))
    (o: 'Accessor : Arguments',
      -> (new Declaration '->' (new Arguments 'it'),
        (new Call (new Access 'it' $1) $3)))
    (o: 'COMPARE Value',
      -> (new Declaration '->' (new Arguments 'it'),
        (new Compare 'it' $1 $2)))
    (o: 'LEFT_OPERATORS Value',
      -> (new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o: '= Value' -> (new Declaration '->' (new Arguments 'it') $2))
    (o: '+ Value',
      -> (new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o: '- Value',
      -> (new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o: '* Value',
      -> (new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o: '* * Value',
      -> (new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' '**' $3)))
    (o: '/ Value',
      -> (new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
  ]

  @SpecialFunctions [
    (o: '( SugaryFunctions )' -> ($2))
  ]

  @Operation [
    (o: 'Value COMPARE OptTerminator Value' -> (new Compare $1 $2 $4))
    (o: 'Value LOGIC OptTerminator Value' -> (new Logic $1 $2 $4))
    (o: 'Value LEFT_OPERATORS OptTerminator Value',
      -> (new Operation $1 $2 $4))
    (o: 'Value RIGHT_OPERATORS OptTerminator Value',
      -> (new Operation $1 $2 $4))
    (o: 'NOT Value' -> (new Compare $2 $1))
    (o: 'Value + OptTerminator Value' -> (new Operation $1 '+' $4))
    (o: 'Value - OptTerminator Value' -> (new Operation $1 '-' $4))
    (o: 'Value * OptTerminator Value' -> (new Operation $1 '*' $4))
    (o: 'Value * * OptTerminator Value' -> (new Operation $1 '**' $5))
    (o: 'Value / OptTerminator Value' -> (new Operation $1 '/' $4))
  ]
}


tokens = [
  'ASSERT' 'IF' 'THEN' 'ELSE'
  'FN' 'MATCH' 'KEY' 'LAMBDA'
  'IDENTIFIER' 'BOOL' 'NUM' 'STR'
  'LOGIC' 'COMPARE' 'DO' 'RETURN'
  'TERMINATOR'
]

operators = [
  ['right' 'NOT']
  ['right' 'IF' 'THEN' 'ELSE' 'IMPORT' 'EXPORT']
  ['right' '=' '|']
  ['right' 'RIGHT_OPERATORS']
  ['nonassoc' '(' ')' '[' ']' '{' '}' ':']
  ['left' 'LOGIC']
  ['left' 'COMPARE']
  ['left' 'LEFT_OPERATORS']
  ['left' '+' '-']
  ['left' '*' '**' '/']
]

parser = new jison.Parser { @tokens @bnf @operators @start-symbol }
parser.lexer = {
  @lex (fn [] {
    ref = this.tokens !! this.pos || ['']
    this.pos = this.pos + 1
    this.yytext = ref !! 1
    this.yylineno = ref !! 2
    ref !! 0
  })

  @set-input (fn [tokens] {
    this.tokens = tokens
    this.pos = 0
  })
}

module.exports = parser
