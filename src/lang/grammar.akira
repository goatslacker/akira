jison = require 'jison'

unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*)\s*\}/

macro jsn fn [name & args] {
  { @type 'NewExpression'
    @callee name
    @arguments args }
}

macro n fn [name & args] {
  { @type 'CallExpression'
    @callee {
      @type 'MemberExpression'
      @computed false
      @object { @type 'Identifier' @name 'yy' }
      @property { @type 'Identifier' @name 'L' }
    }
    @arguments [
      { @type 'Identifier' @name 'yylineno' }
      { @type 'NewExpression'
        @callee {
          @type 'MemberExpression'
          @computed false
          @object { @type 'Identifier' @name 'yy' }
          @property name
        }
        @arguments args
      }
    ]
  }
}

get-match = fn [action] {
  x = unwrap.exec action
  if x then x.1 else '({{action}}())'
}

o = fn [pattern action] {
  pattern-string = pattern.replace /\s{2,}/g, ' '
  if not action
    then [pattern-string '$$ = $1']
    else {
      xaction = action | get-match
      [pattern-string '$$ = {{xaction}}']
    }
}

start-symbol = 'Root'

bnf = {
  @Root [
    ['' 'return $$ = new yy.Nodes;']
    ['Program' 'return $$ = $1']
  ]

  @Program [
    (o 'Terminator Statements' (= $2))
    (o 'Terminator' (= none))
    (o 'Statements')
  ]

  @Statements [
    (o 'Body' (-> yy.Nodes.wrap $1))
    (o 'Statements TERMINATOR Body' (-> $1.push $3))
    (o 'Statements ; Body' (-> $1.push $3))
    (o 'Statements TERMINATOR')
  ]

  @Terminator [
    (o 'TERMINATOR')
    (o 'Terminator TERMINATOR')
  ]

  @OptTerminator [
    (o '')
    (o 'Terminator')
  ]

  @Identifier [
    (o 'IDENTIFIER' (-> n Identifier $1))
  ]

  @Prototype [
    (o 'PROTOTYPE' (-> n Identifier '__prototype'))
  ]

  @Rest [
    (o '& IDENTIFIER' (-> n Identifier $2 true))
  ]

  @TBody [
    (o '{ OptTerminator Statements }' (-> $3))
  ]

  @Body [
    (o 'TBody')
    (o 'Statement')
  ]

  @Statement [
    (o 'Exporting')
    (o 'Expression')
    (o 'Recur')
    (o 'DefMacro')
    (o 'TypeSignature')
    (o 'TypeAlias')
  ]

  @Expression [
    (o 'Value')
    (o 'If')
    (o 'Assignment')
    (o 'PatternMatching')
    (o 'Cond')
    (o 'Invocation')
    (o 'InlineDeclaration')
    (o 'Async')
    (o 'AsyncDo')
    (o 'MaybeSeq')
    (o 'Let')
    (o 'Pipeline')
    (o 'Cloning')
    (o 'Instantiate')
    (o 'Macro')
    (o 'Raise')
    (o 'Exceptions')
    (o 'IMPORT STR' (-> n Import $2))
  ]

  @Value [
    (o 'Accessibles')
    (o 'Class')
    (o 'Operation')
  ]

  @Callable [
    (o 'Identifier')
    (o 'Declaration')
    (o 'ArgumentsShorthand')
    (o 'Access')
  ]

  @Accessibles [
    (o 'Callable')
    (o 'Literal')
    (o 'Vectors')
    (o 'Maps')
    (o 'Type')
    (o 'Prototype')
    (o 'SpecialFunctions')
    (o 'ArgumentsShorthand ^ Identifier' (-> n Assignment $3 $1))
    (o '( OptTerminator Expression OptTerminator )' (-> $3))
  ]

  @ArgumentsShorthand [
    (o 'ARGS' (-> 'arguments[{{$1}}]'))
  ]

  @Literal [
    (o 'AlphaNumeric')
    (o 'NONE' (-> n Literal none))
    (o 'BOOL' (-> n Literal ($1 is 'true')))
    (o 'REGEXP' (-> n Literal $1))
  ]

  @AlphaNumeric [
    (o 'NUM' (-> n Literal (Number ($1.replace /,/g, ''))))
    (o 'Strings')
  ]

  @Strings [
    (o 'STR' (-> n Literal (String $1)))
  ]

  @Assignment [
    (o 'Identifier = Expression' (-> n Assignment $1 $3))
    (o 'Access = Expression' (-> n Assignment $1 $3))
    (o 'Vectors = Expression' (-> n Assignment $1 $3))
    (o 'Maps = Expression' (-> n Assignment $1 $3))
    (o 'AccessOperation = Expression' (-> n Assignment $1 $3))
  ]

  @Exporting [
    (o 'EXPORT Expression' (-> n Export $2))
  ]

  @Cloning [
    (o 'Identifier : Arguments' (-> n Cloning $3 $1))
    (o 'Maps Arguments' (-> n Cloning $2 $1))
    (o 'Vectors Arguments' (-> n Cloning $2 $1))
  ]

  @CallableValue [
    (o 'Value')
    (o 'Invocation')
  ]

  @Pipeline [
    (o 'Value | OptTerminator CallableValue' (-> n Pipeline $1 $4))
    (o 'Invocation | OptTerminator CallableValue' (-> n Pipeline $1 $4))
    (o 'Pipeline | OptTerminator CallableValue' (-> n Pipeline $1 $4))
  ]

  @Invocation [
    (o 'Callable Arguments' (-> n Call $1 $2))
    (o 'Callable !' (-> n Call $1))
    (o 'Callable & !' (-> n Call $1, 'apply'))
  ]

  @Declaration [
    (o 'FN [ Parameters ] TBody' (-> n Declaration none $3 $5))
    (o 'FN [ ] TBody' (-> n Declaration none none $4))
    (o 'LAMBDA TBody' (-> n Declaration none none $2))
  ]

  @InlineDeclaration [
    (o 'FN [ Parameters ] Expression' (-> n Declaration none $3 $5))
    (o 'FN [ Parameters ] TERMINATOR Expression' (-> n Declaration none $3 $6))
    (o 'FN [ ] Expression' (-> n Declaration none none $4))
    (o 'LAMBDA Expression' (-> n Declaration none none $2))
  ]

  @LetOperation [
    (o 'Assignment Terminator')
  ]

  @LetOperations [
    (o 'LetOperation' (-> n Arguments $1))
    (o 'LetOperations LetOperation' (-> n Arguments $1 $2))
  ]

  @Let [
    (o 'LET OptTerminator LetOperations THEN OptTerminator Expression TERMINATOR' (-> n Let $3 $6))
  ]

  @MaybeParameters [
    (o 'Value' (-> n Arguments $1))
    (o 'MaybeParameters OptComma Value' (-> n Arguments $1 $3))
  ]

  @MaybeSeq [
    (o 'MAYBE Value' (-> n MaybeSeq $2))
    (o 'MAYBE Value TBody' (-> n MaybeSeq $2 $3))
  ]

  @Async [
    (o 'TASK [ ] TBody' (-> n Async none $4))
    (o 'TASK [ Parameters ] TBody' (-> n Async $3 $5))
  ]

--  @AsyncDo [
--    (o 'DO CallableValue Declaration' (-> n Do $3 $4))
--  ]

  @Conditional [
    (o 'Value ? Body Terminator' (-> [$1 $3]))
  ]

  @Conditionals [
    (o 'Conditional' (-> n Arguments $1))
    (o 'Conditionals Conditional' (-> n Arguments $1 $2))
  ]

  @CondElse [
    (o 'ELSE ? Body' (-> [$1 $3]))
  ]

  @Cond [
    (o 'COND TERMINATOR Conditionals CondElse' (-> n Cond $3 $4))
  ]

  @Pattern [
    (o '[ ] Body TERMINATOR' (-> [none $3]))
    (o '[ VectorArgs ] Body TERMINATOR' (-> [$2 $4]))
    (o '[ ELSE ] Body TERMINATOR' (-> [$2 $4]))
  ]

  @Patterns [
    (o 'Pattern' (-> n Arguments $1))
    (o 'Patterns Pattern' (-> n Arguments $1 $2))
  ]

  @PatternMatching [
    (o 'MATCH { OptTerminator Patterns }' (-> n Pattern $4))
  ]

  @Comma [
    (o '')
    (o ', OptTerminator')
  ]

  @Vectors [
    (o '[ ]' (-> n Vector))
    (o '[ OptTerminator VectorArgs OptTerminator ]' (-> n Vector $3))
  ]

  @VectorArg [
    (o 'Value')
    (o 'Rest')
    (o 'CATCH')
  ]

  @VectorArgs [
    (o 'VectorArg' (-> n Arguments $1))
    (o 'VectorArgs OptComma VectorArg' (-> n Arguments $1 $3))
  ]

  @Key [
    (o 'KEY' (-> n Identifier $1))
  ]

  @KeyValue [
    (o 'Key' (-> n Assignment $1 none))
    (o 'Key Value' (-> n Assignment $1 $2))
  ]

  @MapItems [
    (o 'KeyValue' (-> n Arguments $1))
    (o 'MapItems OptComma KeyValue' (-> n Arguments $1 $3))
  ]

  @TypeAlias [
    (o 'TYPEALIAS Identifier TypeValues',
      (-> n TypeAlias (n TypeSignature $2 '' $3)))
  ]

  @Maps [
    (o '{ }' (-> n Map))
    (o '{ OptTerminator MapItems OptTerminator }' (-> n Map $3))
  ]

  @Access [
    (o 'Accessibles Accessor' (-> n Access $1 $2))
  ]

  @Accessor [
    (o '. Identifier' (-> $2))
    (o '. Literal' (-> $2))
    (o '. PROTOTYPE' (-> $2))
  ]

  @Arguments [
    (o 'Value' (-> n Arguments $1))
    (o 'Arguments Comma Value' (-> n Arguments $1 $3))
  ]

  @Param [
    (o 'Identifier')
    (o '( Identifier = Value )' (-> n Assignment $2 $4))
    (o 'Rest')
    (o 'Vectors')
  ]

  @OptComma [
    (o ', OptTerminator')
    (o 'OptTerminator')
  ]

  @Parameters [
    (o 'Param' (-> n Arguments $1))
    (o 'Parameters OptComma Param' (-> n Arguments $1 $3))
  ]

  @ClassMethod [
    (o 'Identifier [ Parameters ] TBody' (-> n ClassMethod $1 $3 $5))
    (o 'Identifier [ ] TBody' (-> n ClassMethod $1 none $4))
  ]

  @ClassMethods [
    (o 'ClassMethod' (-> n Arguments $1))
    (o 'ClassMethods Terminator ClassMethod' (-> n Arguments $1 $3))
  ]

  @Constructor [
    (o '[ Parameters ] TBody' (-> n ClassMethod none $2 $4))
    (o '[ ] TBody' (-> n ClassMethod none none $3))
  ]

  @Class [
    (o 'CLASS { Terminator Constructor Terminator }' (-> n Class $4 []))
    (o 'CLASS { Terminator Constructor Terminator ClassMethods Terminator }' (-> n Class $4 $6))
  ]

  @Instantiate [
    (o 'NEW Invocation' (-> n Instantiate $2))
  ]

  @Exceptions [
    (o 'TRY Body OptTerminator CATCH Identifier Body' (-> n ExceptionGuard $2 $5 $6))
  ]

  @Raise [
    (o 'RAISE Value ErrorType' (-> n Exception $1 $2 $3))
  ]

  @ErrorType [
    (o '' (-> none))
    (o 'Identifier')
  ]

  @Recur [
    (o 'RECUR OptTerminator Arguments' (-> n Recur $3))
    (o '( RECUR OptTerminator Arguments )' (-> n Recur $4))
  ]

  @If [
    (o 'Value IF CallableValue' (-> n If $3 $1 none))
    (o 'IF CallableValue OptTerminator THEN Body OptTerminator ELSE Body',
      (-> n If $2 $5 $8))
  ]

  @DefMacro [
    (o 'MACRO Identifier Declaration' (-> n Macro $2 $3))
  ]

  @TypeValues [
    (o 'Identifier')
    (o 'VectorType')
    (o 'MapType')
    (o 'MAYBE TypeValues' (-> n Type $2 'maybe'))
  ]

  @TypeValue [
    (o 'TypeValues')
    (o 'TypeValues | TypeValue' (-> n Type [$1 $3] 'or'))
  ]

  @VectorType [
    (o '[ TypeParams ]' (-> n Type $2 'vector'))
  ]

  @MapType [
    (o '{ OptTerminator MapTypeParams OptTerminator }' (-> n Type $3 'map'))
  ]

  @MaybeTypeParams [
    (o '')
    (o 'TypeParams')
  ]

  @TypeKeyValue [
    (o 'Key' (-> n Assignment $1 none))
    (o 'Key TypeValue' (-> n Assignment $1 $2))
  ]

  @MapTypeParams [
    (o 'TypeKeyValue' (-> n Arguments $1))
    (o 'MapTypeParams TypeKeyValue' (-> n Arguments $1 $2))
  ]

  @TypeParams [
    (o 'TypeValue' (-> n Arguments $1))
    (o 'TypeParams TypeValue' (-> n Arguments $1 $2))
  ]

  @TypeSignature [
    (o 'Identifier TYPE_OPERATOR MaybeTypeParams LAMBDA TypeValue',
      (-> n TypeSignature $1 $3 $5))
  ]

  @Macro [
    (o '` OptTerminator Statement' (-> n Evaluate $3))
    (o '~ OptTerminator Statement' (-> n Evaluate $3 true))
  ]

  @Operators [
    (o '+' (-> n Identifier 'sum'))
    (o '-' (-> n Identifier 'sub'))
    (o '*' (-> n Identifier 'prod'))
    (o '* *' (-> n Identifier 'pow'))
    (o '/' (-> n Identifier 'div'))
    (o 'COMPARE' (-> n Compare $1))
    (o 'LOGIC' (-> n Logic $1))
  ]

  @SugaryFunctions [
    (o 'Operators' (-> $1))
    (o 'Accessor',
      (-> n Declaration '->' (n Arguments 'it'),
        (n Access 'it' $1)))
    (o 'Accessor Arguments',
      (-> n Declaration '->' (n Arguments 'it'),
        (n Call (n Access 'it' $1) $2)))
    (o 'COMPARE Value',
      (-> n Declaration '->' (n Arguments 'it'),
        (n Compare 'it' $1 $2)))
    (o 'LEFT_OPERATORS Value',
      (-> n Declaration '->' (n Arguments 'it'),
        (n Operation 'it' $1 $2)))
    (o 'ACCESSOR_OPERATOR Value',
      (-> n Declaration '->' (n Arguments 'it'),
        (n Operation 'it' $1 $2)))
    (o '= Value' (-> n Declaration '->' (n Arguments 'it') $2))
    (o '+ Value',
      (-> n Declaration '->' (n Arguments 'it'),
        (n Operation 'it' $1 $2)))
    (o '- Value',
      (-> n Declaration '->' (n Arguments 'it'),
        (n Operation 'it' $1 $2)))
    (o '* Value',
      (-> n Declaration '->' (n Arguments 'it'),
        (n Operation 'it' $1 $2)))
    (o '* * Value',
      (-> n Declaration '->' (n Arguments 'it'),
        (n Operation 'it' '**' $3)))
    (o '/ Value',
      (-> n Declaration '->' (n Arguments 'it'),
        (n Operation 'it' $1 $2)))
  ]

  @SpecialFunctions [
    (o '( SugaryFunctions )' (-> $2))
  ]

  @AccessOperation [
    (o 'Value ACCESSOR_OPERATOR OptTerminator Value',
      (-> n Operation $1 $2 $4))
  ]

  @Operation [
    (o 'Value COMPARE OptTerminator Value' (-> n Compare $1 $2 $4))
    (o 'Value LOGIC OptTerminator Value' (-> n Logic $1 $2 $4))
    (o 'AccessOperation')
    (o 'Value LEFT_OPERATORS OptTerminator Value',
      (-> n Operation $1 $2 $4))
    (o 'Value RIGHT_OPERATORS OptTerminator Value',
      (-> n Operation $1 $2 $4))
    (o 'NOT Value' (-> n Compare $2 $1))
    (o 'Value + OptTerminator Value' (-> n Operation $1 '+' $4))
    (o 'Value - OptTerminator Value' (-> n Operation $1 '-' $4))
    (o 'Value * OptTerminator Value' (-> n Operation $1 '*' $4))
    (o 'Value * * OptTerminator Value' (-> n Operation $1 '**' $5))
    (o 'Value / OptTerminator Value' (-> n Operation $1 '/' $4))
  ]
}


tokens = [
  'ASSERT' 'IF' 'THEN' 'ELSE'
  'FN' 'MATCH' 'KEY' 'LAMBDA'
  'IDENTIFIER' 'BOOL' 'NUM' 'STR'
  'LOGIC' 'COMPARE' 'DO' 'RETURN'
  'TERMINATOR'
]

operators = [
  ['right' 'NOT']
  ['right' 'IF' 'THEN' 'ELSE' 'IMPORT' 'EXPORT']
  ['right' '=' '|']
  ['right' 'RIGHT_OPERATORS']
  ['nonassoc' '(' ')' '[' ']' '{' '}' ':']
  ['left' 'LOGIC']
  ['left' 'COMPARE']
  ['left' 'LEFT_OPERATORS']
  ['left' 'ACCESSOR_OPERATOR']
  ['left' '+' '-']
  ['left' '*' '**' '/']
]

parser = jsn jison.Parser { @tokens @bnf @operators @start-symbol }
parser.lexer = {
  @lex (fn [] {
    ref = this.tokens !! this.pos || ['']
    this.pos = this.pos + 1
    this.yytext = ref.1
    this.yylineno = ref.2
    ref.0
  })

  @set-input (fn [tokens] {
    this.tokens = tokens
    this.pos = 0
  })
}

module.exports = parser
