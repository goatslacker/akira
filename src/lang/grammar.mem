jison = require: 'jison'

unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*)\s*\}/

getMatch = fn [action] {
  x = unwrap.exec: action
  if x then x.2 else '({{action}}())'
}

addYY = fn [str] str.replace: /new /g, 'new yy.'
addLine = fn [str] 'yy.L(yylineno, ' ++ (str.replace: ';', '') ++ ');'

o = fn [pattern action] {
  pattern-string = pattern.replace: /\s{2,}/g, ' '
  if not action
    then [pattern-string, '$$ = $1']
    else {
      newaction = action | getMatch | addYY | addLine
      [pattern-string, '$$ = {{newaction}}']
    }
}

bnf = #{
  Root = [
    ['', 'return $$ = new yy.Nodes;']
    ['Program', 'return $$ = $1']
  ]

  Program = [
    (o: 'Terminator Expressions', (fn [] $2))
    (o: 'Expressions')
  ]

  Expressions = [
    (o: 'Body', (fn [] yy.Nodes.wrap: $1))
    (o: 'Expressions TERMINATOR Body', (fn [] $1.push: $3))
    (o: 'Expressions ; Body', (fn [] $1.push: $3))
    (o: 'Expressions TERMINATOR')
  ]

  Terminator = [
    (o: 'TERMINATOR')
    (o: 'Terminator TERMINATOR')
  ]

  OptTerminator = [
    (o: '')
    (o: 'Terminator')
  ]

  Identifier = [
    (o: 'IDENTIFIER', (fn [] clone Identifier: $1))
  ]

  Prototype = [
    (o: 'PROTOTYPE', (fn [] clone Identifier: $1))
  ]

  Rest = [
    (o: '. . . IDENTIFIER', (fn [] clone Identifier: $4, true))
  ]

  Body = [
    (o: 'Expression')
    (o: '{ OptTerminator Expressions }', (fn [] $3))
  ]

  Expression = [
    (o: 'Exporting')
    (o: 'Assignable')
    (o: 'Exceptions')
    (o: 'Objects')
    (o: 'Recur')
    (o: 'DefMacro')
  ]

  Assignable = [
    (o: 'Value')
    (o: 'If')
    (o: 'Assignment')
    (o: 'Declaration')
    (o: 'PatternMatching')
    (o: 'Invocation')
    (o: 'Pipeline')
    (o: 'Cloning')
    (o: 'Comprehensions')
    (o: 'Prototype')
    (o: 'Macro')
    (o: 'IMPORT STR', (fn [] clone Import: $2))
  ]

  Value = [
    (o: 'Literal')
    (o: 'Lists')
    (o: 'Maps')
    (o: 'Operation')
    (o: 'Access')
    (o: 'Type')
    (o: 'SpecialFunctions')
    (o: '( Assignable )', (fn [] $2))
  ]

  Values = [
    (o: 'Value')
    (o: 'Invocation')
  ]

  Type = [
    (o: 'TYPE', (fn [] clone Identifier: $1))
  ]

  Literal = [
    (o: 'Identifier')
    (o: 'AlphaNumeric')
    (o: 'NONE', (fn [] clone Literal: none))
    (o: 'BOOL', (fn [] clone Literal: ($1 == 'true')))
    (o: 'REGEXP', (fn [] clone Literal: $1))
  ]

  AlphaNumeric = [
    (o: 'NUM', (fn [] clone Literal: (Number: $1)))
    (o: 'Strings')
  ]

  Strings = [
    (o: 'STR', (fn [] clone Literal: (String: $1)))
  ]

  Assignment = [
    (o: 'Identifier = Assignable', (fn [] clone Assignment: $1, $3))
    (o: 'Access = Assignable', (fn [] clone Assignment: $1, $3))
    (o: 'Lists = Assignable', (fn [] clone Assignment: $1, $3))
    (o: 'Maps = Assignable', (fn [] clone Assignment: $1, $3))
  ]

  Objects = [
    (o: 'OBJECT Identifier OptClones Maps', (fn [] clone Objects: $2, $3, $4))
  ]

  OptClones = [
    (o: '', (fn [] none))
    (o: 'CLONES Identifier', (fn [] $2))
  ]

  Exporting = [
    (o: 'EXPORT Assignable', (fn [] clone Export: $2))
  ]

  Cloning = [
    (o: 'CLONE Invocation', (fn [] clone Construction: $2))
  ]

  Pipeline = [
    (o: 'Value | OptTerminator Values', (fn [] clone Pipeline: $1, $4))
    (o: 'Invocation | OptTerminator Values', (fn [] clone Pipeline: $1, $4))
    (o: 'Pipeline | OptTerminator Values', (fn [] clone Pipeline: $1, $4))
  ]

  Invocation = [
    (o: 'Value : Arguments', (fn [] clone Call: $1, $3))
    (o: 'Value !', (fn [] clone Call: $1))
  ]

  Declaration = [
    (o: 'FN [ Parameters ] Body', (fn [] clone Declaration: none, $3, $5))
    (o: 'FN [ ] Body', (fn [] clone Declaration: none, none, $4))
  ]

  Pattern = [
    (o: 'Value ? Body TERMINATOR', (fn [] [$1, $3] ))
  ]

  Patterns = [
    (o: 'Pattern', (fn [] clone Arguments: $1))
    (o: 'Patterns Pattern', (fn [] clone Arguments: $1, $2))
  ]

  Default = [
    (o: 'ELSE ? Body TERMINATOR', (fn [] clone Arguments: [$1, $3]))
  ]

  PatternMatching = [
    (o: 'FN [ Parameters ] TERMINATOR Patterns Default',
      (fn [] clone Declaration: none, $3, (clone Pattern: $3, $6, $7)))
  ]

  Comma = [
    (o: ', OptTerminator')
  ]

  Comprehensions = [
    (o: 'NUM . . Numbers ComprehensionBy ComprehensionFunction',
      (fn [] clone Comprehension: $1, $4, $5, $6))
    (o: 'Identifier . . Numbers ComprehensionBy ComprehensionFunction',
      (fn [] clone Comprehension: $1, $4, $5, $6))
  ]

  Numbers = [
    (o: 'NUM')
    (o: 'Identifier')
  ]

  ComprehensionFunction = [
    (o: '', (fn [] none))
    (o: ', Declaration', (fn [] $2))
  ]

  ComprehensionBy = [
    (o: '', (fn [] clone Literal: 1))
    (o: 'Numbers')
  ]

  Lists = [
    (o: '[ ]', (fn [] clone List!))
    (o: '[ OptTerminator ListArgs OptTerminator ]', (fn [] clone List: $3))
  ]

  ListArgs = [
    (o: 'Arg', (fn [] clone Arguments: $1))
    (o: 'ListArgs Comma Arg', (fn [] clone Arguments: $1, $3))
    (o: 'ListArgs Terminator Arg', (fn [] clone Arguments: $1, $3))
  ]

  Key = [
    'Identifier',
    'Strings'
  ]

  KeyValue = [
    (o: 'Key', (fn [] clone Assignment: $1, $1))
    (o: 'Key = Value', (fn [] clone Assignment: $1, $3))
  ]

  MapItems = [
    (o: 'KeyValue', (fn [] clone Arguments: $1))
    (o: 'MapItems Comma KeyValue', (fn [] clone Arguments: $1, $3))
    (o: 'MapItems Terminator KeyValue', (fn [] clone Arguments: $1, $3))
  ]

  Maps = [
    (o: '# { }', (fn [] clone Map!))
    (o: '# { OptTerminator MapItems OptTerminator }',
      (fn [] clone Map: #{ obj = $4 }))
  ]

  Access = [
    (o: 'Identifier Accessor', (fn [] clone Access: $1, $2))
    (o: 'Prototype Accessor', (fn [] clone Access: $1, $2))
    (o: 'Type Accessor', (fn [] clone Access: $1, $2))
    (o: 'Access Accessor', (fn [] clone Access: $1, $2))
  ]

  Accessor = [
    (o: '. Identifier', (fn [] $2))
    (o: '. AlphaNumeric', (fn [] $2))
  ]

  Arg = [
    (o: 'Value')
    (o: 'Rest')
  ]

  Arguments = [
    (o: '()', (fn [] none))
    (o: 'Arg', (fn [] clone Arguments: $1))
    (o: 'Arguments Comma Arg', (fn [] clone Arguments: $1, $3))
  ]

  Param = [
    (o: 'Identifier')
    (o: '( Identifier = Value )', (fn [] clone Assignment: $2, $4))
    (o: 'Rest')
    (o: 'Lists')
  ]

  OptComma = [
    (o: '')
    (o: 'TERMINATOR')
    (o: ',')
  ]

  Parameters = [
    (o: 'Param', (fn [] clone Arguments: $1))
    (o: 'Parameters OptComma Param', (fn [] clone Arguments: $1, $3))
  ]

  Exceptions = [
    (o: 'TRY Body OptTerminator CATCH Body', (fn [] clone Exception: $2, $5))
    (o: 'RAISE Value ErrorType', (fn [] clone Exception: $1, $2, $3))
  ]

  ErrorType = [
    (o: '', (fn [] none))
    (o: 'Identifier')
  ]

  Recur = [
    (o: 'RECUR OptTerminator Arguments', (fn [] clone Recur: $3))
    (o: '( RECUR OptTerminator Arguments )', (fn [] clone Recur: $4))
  ]

  If = [
    (o: 'IF Values OptTerminator THEN Body OptTerminator ELSE Body',
      (fn [] clone If: $2, $5, $8))
  ]

  DefMacro = [
    (o: 'MACRO Identifier Declaration', (fn [] clone Macro: true, $2, $3))
  ]

  Macro = [
    (o: 'Identifier Arguments', (fn [] clone Macro: false, $1, $2))
  ]

  MathOperators = [
    (o: '+', (fn [] clone Identifier: 'sum'))
    (o: '-', (fn [] clone Identifier: 'sub'))
    (o: '*', (fn [] clone Identifier: 'prod'))
    (o: '/', (fn [] clone Identifier: 'div'))
  ]

  SugaryFunctions = [
    (o: 'MathOperators', (fn [] $1))
    (o: 'Accessor',
      (fn [] clone Declaration: '->', (clone Arguments: 'it'),
        (clone Access: 'it', $1)))
    (o: 'Accessor : Value',
      (fn [] clone Declaration: '->', (clone Arguments: 'it'),
        (clone Call: (clone Access: 'it', $1), $3)))
    (o: 'COMPARE Value',
      (fn [] clone Declaration: '->', (clone Arguments: 'it'),
        (clone Compare: 'it', $1, $2)))
    (o: 'LEFT_OPERATORS Value',
      (fn [] clone Declaration: '->', (clone Arguments: 'it'),
        (clone Operation: 'it', $1, $2)))
    (o: '+ Value',
      (fn [] clone Declaration: '->', (clone Arguments: 'it'),
        (clone Operation: 'it', $1, $2)))
    (o: '- Value',
      (fn [] clone Declaration: '->', (clone Arguments: 'it'),
        (clone Operation: 'it', $1, $2)))
    (o: '* Value',
      (fn [] clone Declaration: '->', (clone Arguments: 'it'),
        (clone Operation: 'it', $1, $2)))
    (o: '/ Value',
      (fn [] clone Declaration: '->', (clone Arguments: 'it'),
        (clone Operation: 'it', $1, $2)))
  ]

  SpecialFunctions = [
    (o: '( SugaryFunctions )', (fn [] $2))
  ]

  Operation = [
    (o: 'Value COMPARE OptTerminator Value', (fn [] clone Compare: $1, $2, $4))
    (o: 'Value LOGIC OptTerminator Value', (fn [] clone Compare: $1, $2, $4))
    (o: 'Value LEFT_OPERATORS OptTerminator Value', (fn [] clone Operation: $1, $2, $4))
    (o: 'Value RIGHT_OPERATORS OptTerminator Value', (fn [] clone Operation: $1, $2, $4))
    (o: 'NOT Value', (fn [] clone Compare: $2, $1))
    (o: 'Value + OptTerminator Value', (fn [] clone Operation: $1, '+', $4))
    (o: 'Value - OptTerminator Value', (fn [] clone Operation: $1, '-', $4))
    (o: 'Value * OptTerminator Value', (fn [] clone Operation: $1, '*', $4))
    (o: 'Value / OptTerminator Value', (fn [] clone Operation: $1, '/', $4))
  ]
}


tokens = [
  'ASSERT', 'IF', 'THEN', 'ELSE',
  'LAMBDA',
  'IDENTIFIER', 'BOOL', 'NUM', 'STR',
  'LOGIC', 'COMPARE',
  'TERMINATOR'
]

operators = [
  ['right', 'NOT']
  ['right', 'IF', 'THEN', 'ELSE', 'IMPORT', 'EXPORT']
  ['right', '=', '|']
  ['right', 'RIGHT_OPERATORS']
  ['nonassoc', '(', ')', '[', ']', '{', '}', ':']
  ['left', 'LOGIC']
  ['left', 'COMPARE']
  ['left', 'LEFT_OPERATORS']
  ['left', '+', '-']
  ['left', '*', '/']
]

Parser = jison.Parser
grammar = #{
  tokens = tokens
  bnf = bnf
  operators = operators
  startSymbol = 'Root'
}

parser = clone Parser: grammar
lexer = #{
  lex = (fn [] {
    ref = this.tokens !! this.pos || ['']
    this.pos = this.pos + 1
    this.yytext = ref !! 1
    this.yylineno = ref !! 2
    ref !! 0
  })
  set-input = (fn [tokens] {
    this.tokens = tokens
    this.pos = 0
  })
}
parser.lexer = lexer

export parser
