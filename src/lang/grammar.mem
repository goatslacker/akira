jison = require: 'jison'

unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*)\s*\}/

macro new fn [name & args] {
  @type 'NewExpression'
  @callee name
  @arguments args
}

get-match = fn [action] {
  x = unwrap.exec: action
  if x then x.2 else '({{action}}())'
}

addYY = fn [str] str.replace: /new /g, 'new yy.'
add-line = fn [str] 'yy.L(yylineno, ' ++ (str.replace: ';', '') ++ ');'

o = fn [pattern action] {
  pattern-string = pattern.replace: /\s{2,}/g, ' '
  if not action
    then [pattern-string '$$ = $1']
    else {
      newaction = action | get-match | addYY | add-line
      [pattern-string '$$ = {{newaction}}']
    }
}

start-symbol = 'Root'

bnf = {
  @Root [
    ['' 'return $$ = new yy.Nodes;']
    ['Program' 'return $$ = $1']
  ]

  @Program [
    (o: 'Terminator Expressions' (fn [] $2))
    (o: 'Terminator' (fn [] none))
    (o: 'Expressions')
  ]

  @Expressions [
    (o: 'Body' (fn [] yy.Nodes.wrap: $1))
    (o: 'Expressions TERMINATOR Body' (fn [] $1.push: $3))
    (o: 'Expressions ; Body' (fn [] $1.push: $3))
    (o: 'Expressions TERMINATOR')
  ]

  @Terminator [
    (o: 'TERMINATOR')
    (o: 'Terminator TERMINATOR')
  ]

  @OptTerminator [
    (o: '')
    (o: 'Terminator')
  ]

  @Identifier [
    (o: 'IDENTIFIER' (fn [] new Identifier $1))
  ]

  @Prototype [
    (o: 'PROTOTYPE' (fn [] new Identifier $1))
  ]

  @Rest [
    (o: '& IDENTIFIER' (fn [] new Identifier $2 true))
  ]

  @Body [
    (o: 'Expression')
    (o: '{ OptTerminator Expressions }' (fn [] $3))
  ]

  @Expression [
    (o: 'Exporting')
    (o: 'Assignable')
    (o: 'Exceptions')
    (o: 'Recur')
    (o: 'DefMacro')
  ]

  @Assignable [
    (o: 'Value')
    (o: 'If')
    (o: 'Assignment')
    (o: 'Declaration')
    (o: 'PatternMatching')
    (o: 'Invocation')
    (o: 'Pipeline')
    (o: 'Cloning')
    (o: 'Prototype')
    (o: 'Macro')
    (o: 'IMPORT STR' (fn [] new Import $2))
  ]

  @Value [
    (o: 'Literal')
    (o: 'Lists')
    (o: 'Maps')
    (o: 'Operation')
    (o: 'Access')
    (o: 'Type')
    (o: 'SpecialFunctions')
    (o: 'ARGS' (fn [] 'arguments[{{$1}}]'))
    (o: '( Assignable )' (fn [] $2))
  ]

  @Values [
    (o: 'Value')
    (o: 'Invocation')
  ]

  @Type [
    (o: 'TYPE' (fn [] new Identifier $1))
  ]

  @Literal [
    (o: 'Identifier')
    (o: 'AlphaNumeric')
    (o: 'NONE' (fn [] new Literal none))
    (o: 'BOOL' (fn [] new Literal ($1 is 'true')))
    (o: 'REGEXP' (fn [] new Literal $1))
  ]

  @AlphaNumeric [
    (o: 'NUM' (fn [] new Literal (Number: $1)))
    (o: 'Strings')
  ]

  @Strings [
    (o: 'STR' (fn [] new Literal (String: $1)))
  ]

  @Assignment [
    (o: 'Identifier = Assignable' (fn [] new Assignment $1 $3))
    (o: 'Access = Assignable' (fn [] new Assignment $1 $3))
    (o: 'Lists = Assignable' (fn [] new Assignment $1 $3))
    (o: 'Maps = Assignable' (fn [] new Assignment $1 $3))
  ]

  @Exporting [
    (o: 'EXPORT Assignable' (fn [] new Export $2))
  ]

  @Cloning [
    (o: 'Maps Value' (fn [] new Cloning $2 $1))
    (o: 'Lists Value' (fn [] new Cloning $2 $1))
  ]

  @Pipeline [
    (o: 'Value | OptTerminator Values' (fn [] new Pipeline $1 $4))
    (o: 'Invocation | OptTerminator Values' (fn [] new Pipeline $1 $4))
    (o: 'Pipeline | OptTerminator Values' (fn [] new Pipeline $1 $4))
  ]

  @Invocation [
    (o: 'Value : Arguments' (fn [] new Call $1 $3))
    (o: 'Value !' (fn [] new Call $1))
  ]

  @Declaration [
    (o: 'FN [ Parameters ] Body' (fn [] new Declaration none $3 $5))
    (o: 'FN [ ] Body' (fn [] new Declaration none none $4))
  ]

  @Pattern [
    (o: 'Value ? Body TERMINATOR' (fn [] [$1 $3] ))
  ]

  @Patterns [
    (o: 'Pattern' (fn [] new Arguments $1))
    (o: 'Patterns Pattern' (fn [] new Arguments $1 $2))
  ]

  @Default [
    (o: 'ELSE ? Body TERMINATOR' (fn [] new Arguments [$1 $3]))
  ]

  @PatternMatching [
    (o: 'FN [ Parameters ] TERMINATOR Patterns Default',
      (fn [] new Declaration none $3 (new Pattern $3 $6 $7)))
  ]

  @Comma [
    (o: '')
    (o: ', OptTerminator')
  ]

  @Numbers [
    (o: 'NUM')
    (o: 'Identifier')
  ]

  @Lists [
    (o: '[ ]' (fn [] new List))
    (o: '[ OptTerminator ListArgs OptTerminator ]' (fn [] new List $3))
  ]

  @ListArg [
    (o: 'Value')
    (o: 'Rest')
  ]

  @ListArgs [
    (o: 'ListArg' (fn [] new Arguments $1))
    (o: 'ListArgs OptComma ListArg' (fn [] new Arguments $1 $3))
  ]

  @Key [
    (o: 'KEY' (fn [] new Identifier $1))
  ]

  @KeyValue [
    (o: 'Key' (fn [] new Assignment $1 none))
    (o: 'Key Value' (fn [] new Assignment $1 $2))
  ]

  @MapItems [
    (o: 'KeyValue' (fn [] new Arguments $1))
    (o: 'MapItems OptComma KeyValue' (fn [] new Arguments $1 $3))
  ]

  @Maps [
    (o: '{ }' (fn [] new Map))
    (o: '{ OptTerminator MapItems OptTerminator }' (fn [] new Map $3))
  ]

  @Access [
    (o: 'Identifier Accessor' (fn [] new Access $1 $2))
    (o: 'Prototype Accessor' (fn [] new Access $1 $2))
    (o: 'Type Accessor' (fn [] new Access $1 $2))
    (o: 'Access Accessor' (fn [] new Access $1 $2))
  ]

  @Accessor [
    (o: '. Identifier' (fn [] $2))
    (o: '. AlphaNumeric' (fn [] $2))
  ]

  @Arguments [
    (o: 'Value' (fn [] new Arguments $1))
    (o: 'Arguments Comma Value' (fn [] new Arguments $1 $3))
  ]

  @Param [
    (o: 'Identifier')
    (o: '( Identifier = Value )' (fn [] new Assignment $2 $4))
    (o: 'Rest')
    (o: 'Lists')
  ]

  @OptComma [
    (o: ', OptTerminator')
    (o: 'OptTerminator')
  ]

  @Parameters [
    (o: 'Param' (fn [] new Arguments $1))
    (o: 'Parameters OptComma Param' (fn [] new Arguments $1 $3))
  ]

  @Exceptions [
    (o: 'TRY Body OptTerminator CATCH Body' (fn [] new Exception $2 $5))
    (o: 'RAISE Value ErrorType' (fn [] new Exception $1 $2 $3))
  ]

  @ErrorType [
    (o: '' (fn [] none))
    (o: 'Identifier')
  ]

  @Recur [
    (o: 'RECUR OptTerminator Arguments' (fn [] new Recur $3))
    (o: '( RECUR OptTerminator Arguments )' (fn [] new Recur $4))
  ]

  @If [
    (o: 'IF Values OptTerminator THEN Body OptTerminator ELSE Body',
      (fn [] new If $2 $5 $8))
  ]

  @DefMacro [
    (o: 'MACRO Identifier Declaration' (fn [] new Macro true $2 $3))
  ]

  @Macro [
    (o: 'Identifier Arguments' (fn [] new Macro false $1 $2))
  ]

  @Operators [
    (o: '+' (fn [] new Identifier 'sum'))
    (o: '-' (fn [] new Identifier 'sub'))
    (o: '*' (fn [] new Identifier 'prod'))
    (o: '/' (fn [] new Identifier 'div'))
    (o: 'COMPARE' (fn [] new Compare $1))
    (o: 'LOGIC' (fn [] new Compare $1))

  ]

  @SugaryFunctions [
    (o: 'Operators' (fn [] $1))
    (o: 'Accessor',
      (fn [] new Declaration '->' (new Arguments 'it'),
        (new Access 'it' $1)))
    (o: 'Accessor : Value',
      (fn [] new Declaration '->' (new Arguments 'it'),
        (new Call (new Access 'it' $1) $3)))
    (o: 'COMPARE Value',
      (fn [] new Declaration '->' (new Arguments 'it'),
        (new Compare 'it' $1 $2)))
    (o: 'LEFT_OPERATORS Value',
      (fn [] new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o: '+ Value',
      (fn [] new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o: '- Value',
      (fn [] new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o: '* Value',
      (fn [] new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
    (o: '/ Value',
      (fn [] new Declaration '->' (new Arguments 'it'),
        (new Operation 'it' $1 $2)))
  ]

  @SpecialFunctions [
    (o: '( SugaryFunctions )' (fn [] $2))
  ]

  @Operation [
    (o: 'Value COMPARE OptTerminator Value' (fn [] new Compare $1 $2 $4))
    (o: 'Value LOGIC OptTerminator Value' (fn [] new Compare $1 $2 $4))
    (o: 'Value LEFT_OPERATORS OptTerminator Value',
      (fn [] new Operation $1 $2 $4))
    (o: 'Value RIGHT_OPERATORS OptTerminator Value',
      (fn [] new Operation $1 $2 $4))
    (o: 'NOT Value' (fn [] new Compare $2 $1))
    (o: 'Value + OptTerminator Value' (fn [] new Operation $1 '+' $4))
    (o: 'Value - OptTerminator Value' (fn [] new Operation $1 '-' $4))
    (o: 'Value * OptTerminator Value' (fn [] new Operation $1 '*' $4))
    (o: 'Value / OptTerminator Value' (fn [] new Operation $1 '/' $4))
  ]
}


tokens = [
  'ASSERT' 'IF' 'THEN' 'ELSE'
  'FN' 'KEY' 'LAMBDA'
  'IDENTIFIER' 'BOOL' 'NUM' 'STR'
  'LOGIC' 'COMPARE'
  'TERMINATOR'
]

operators = [
  ['right' 'NOT']
  ['right' 'IF' 'THEN' 'ELSE' 'IMPORT' 'EXPORT']
  ['right' '=' '|']
  ['right' 'RIGHT_OPERATORS']
  ['nonassoc' '(' ')' '[' ']' '{' '}' ':']
  ['left' 'LOGIC']
  ['left' 'COMPARE']
  ['left' 'LEFT_OPERATORS']
  ['left' '+' '-']
  ['left' '*' '/']
]

parser = new jison.Parser { @tokens @bnf @operators @start-symbol }
parser.lexer = {
  @lex (fn [] {
    ref = this.tokens !! this.pos || ['']
    this.pos = this.pos + 1
    this.yytext = ref !! 1
    this.yylineno = ref !! 2
    ref !! 0
  })

  @set-input (fn [tokens] {
    this.tokens = tokens
    this.pos = 0
  })
}

export parser
