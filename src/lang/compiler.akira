escodegen = require 'escodegen'
dune = require 'dune'
lexer = require './lexer'
implicit-return = require 'implicitReturn'
{ @parser } = require './parser'
parser.yy = (require '../lang/nodes')
parser.lexer = {
  @lex (fn [] {
    ref = this.tokens !! this.pos || ['']
    this.pos = this.pos + 1
    this.yytext = ref.1
    this.yylineno = ref.2
    ref.0
  })

  @set-input (fn [tokens] {
    this.tokens = tokens
    this.pos = 0
  })
}
me = require '../../package.json'

HEADER = ' Generated by Akira v' ++ me.version
OPTIONS = {
  @format {
    @indent {
      @style '  '
      @base 0
    }
  }
  @comment true
  @directive true
}

make-program = fn [body context] {
  exported = context !! '$$$exported'
  (body.push exported) if exported
  implicit-return body
  {
    @type 'Program'
    @body [{
      @type 'ExpressionStatement'
      @expression {
        @type 'CallExpression'
        @callee {
          @type 'FunctionExpression'
          @id none
          @params []
          @body {
            @type 'BlockStatement'
            @body body
          }
        }
        @arguments []
      }
      @leading-comments [{
        @type 'Line',
        @value HEADER
      }]
    }]
  }
}

transform = fn [name parsed] {
  cond
    parsed is none ? make-program '' {}
    else ? {
      context = {}
      body = parsed.compile context name
      dependencies = parsed.add-deps context
      parsed.flag-core-methods body
      program-body = (parsed.add-vars context) ++
        (parsed.add-core!) ++
        dependencies ++
        (parsed.add-contracts body)
      make-program program-body context
    }
}

gen-program-ast = fn [name code] {
  lexer code | parser.parse | transform name
}

transpile = fn [name code] {
  escodegen.generate (gen-program-ast name code) OPTIONS
}

run = fn [name code context] {
  try {
    dune.string code name context
  } catch err {
    console.error name
    console.error err.stack
    none
  }
}

module.exports = {
  @gen-program-ast
  @lexer
  @run
  @transpile
}
