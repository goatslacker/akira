fs = require: 'fs'
jison = require: 'jison'

unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*)\s*\}/

getMatch(action) -> (
  x = unwrap.exec: action
  if x then x.2 else '(' ++ action ++ '())'
)
addYY(str) -> str.replace: /new /g, 'new yy.'

o(pattern, action) -> (
  patternString = pattern.replace: /\s{2,}/g, ' '
  if not action
    then [patternString, '$$ = $1']
    else (
      newaction = action | getMatch | addYY
      [patternString, '$$ = ' ++ newaction]
    )
)

bnf = {
  Root = [
    ['', 'return $$ = new yy.Nodes;']
    ['Program', 'return $$ = $1']
  ]

  Program = [
    o: 'Terminator Expressions', (\-> $2);
    o: 'Expressions';
  ]

  Expressions = [
    o: 'Body', (\-> yy.Nodes.wrap: $1);
    o: 'Expressions TERMINATOR Body', (\-> $1.push: $3);
    o: 'Expressions TERMINATOR';
  ]

  Terminator = [
    o: 'TERMINATOR';
    o: 'Terminator TERMINATOR';
  ]

  OptTerminator = [
    o: '';
    o: 'Terminator';
  ]

  Identifier = [
    o: 'IDENTIFIER', (\-> construct Identifier: $1);
  ]

  IdentifierNoUtils = [
    o: 'IDENTIFIER', (\-> construct Identifier: $1, true);
  ]

  Body = [
    o: 'Expression';
    o: '( OptTerminator Expressions )', (\-> $3);
  ]

  SExpression = [
    o: '( Assignable )', (\-> $2);
    o: '( Declaration )', (\-> $2);
  ]

  Expression = [
    o: 'Modules';
    o: 'Assignable';
    o: 'ARGUMENTS';
    o: 'Declaration';
    o: 'PatternMatching';
    o: 'Exceptions';
  ]

  Assignable = [
    o: 'Value';
    o: 'If';
    o: 'Assignment';
    o: 'Invocation';
    o: 'Pipeline';
    o: 'Construct';
  ]

  Value = [
    o: 'Literal';
    o: 'Lists';
    o: 'Tuples';
    o: 'ExplicitInvocation';
    o: 'Operation';
    o: 'Access';
    o: '@';
  ]

  Values = [
    o: 'Value';
    o: 'Invocation';
  ]

  Literal = [
    o: 'Identifier';
    o: 'AlphaNumeric';
    o: 'NONE', (\-> construct Literal: none);
    o: 'BOOL', (\-> construct Literal: ($1 == 'true'));
    o: 'REGEXP', (\-> construct Literal: $1);
  ]

  AlphaNumeric = [
    o: 'NUMBER', (\-> construct Literal: (Number: $1));
    o: 'STRING', (\-> construct Literal: (String: $1));
  ]

  Assignment = [
    o: 'Identifier = Assignable', (\-> construct Assignment: $1, $3);
  ]

  Exported = [
    o: 'Identifier';
    o: 'Declaration';
    o: 'Assignment';
  ]

  Modules = [
    o: 'EXPORT Exported', (\-> construct Export: $2);
    o: 'IMPORT STRING', (\-> construct Import: $2);
  ]

  Construct = [
    o: 'CONSTRUCT Invocation', (\-> construct Construction: $2);
  ]

  Piped = [
    o: 'Values';
    o: 'SExpression';
  ]

  Pipeline = [
    o: 'Value | Piped', (\-> construct Pipeline: $1, $3);
    o: 'Invocation | Piped', (\-> construct Pipeline: $1, $3);
    o: 'Construct | Piped', (\-> construct Pipeline: $1, $3);
    o: 'Pipeline | Piped', (\-> construct Pipeline: $1, $3);
  ]

  Invocation = [
    o: 'Identifier : Arguments', (\-> construct Call: $1, $3);
    o: 'Access : Arguments', (\-> construct Call: $1, $3);
  ]

  ExplicitInvocation = [
    o: 'Invocation ;', (\-> $1);
  ]

  Declaration = [
    o: 'Identifier ( Parameters ) LAMBDA Body', (\-> construct Declaration: $1, $3, $6);
    o: '\ Parameters LAMBDA Body', (\-> construct Declaration: none, $2, $4);
    o: 'LAMBDA Body', (\-> construct Call: (construct Declaration: none, none, $2), none);
  ]

  Pattern = [
    o: 'Value LAMBDA Body TERMINATOR', (\-> [$1, $3] );
  ]

  Patterns = [
    o: 'Pattern', (\-> construct Arguments: $1);
    o: 'Patterns Pattern', (\-> construct Arguments: $1, $2);
  ]

  PatternMatching = [
    o: 'Identifier ( Parameters ) TERMINATOR Patterns', (\-> construct Declaration: $1, $3, (construct Pattern: $3, $6));
  ]

  Comma = [
    o: ', OptTerminator';
  ]

  Lists = [
    o: '[ ]', (\-> construct List:!);
    o: '[ OptTerminator ListArgs OptTerminator ]', (\-> construct List: $3);
  ]

  ListArgs = [
    o: 'Arg', (\-> construct Arguments: $1);
    o: 'ListArgs Comma Arg', (\-> construct Arguments: $1, $3);
    o: 'ListArgs Terminator Arg', (\-> construct Arguments: $1, $3);
  ]

  KeyValue = [
    o: 'IdentifierNoUtils = Value', (\-> construct Assignment: $1, $3);
  ]

  TupleItems = [
    o: 'KeyValue', (\-> construct Arguments: $1);
    o: 'TupleItems Comma KeyValue', (\-> construct Arguments: $1, $3);
    o: 'TupleItems Terminator KeyValue', (\-> construct Arguments: $1, $3);
  ]

  Tuples = [
    o: '{ }', (\-> construct Tuple:!);
    o: '{ OptTerminator TupleItems OptTerminator }', (\-> construct Tuple: $3);
  ]

  Access = [
    o: 'Identifier Accessor', (\-> construct Access: $1, $2);
    o: 'ExplicitInvocation Accessor', (\-> construct Access: $1, $2);
    o: 'Access Accessor', (\-> construct Access: $1, $2);
  ]

  Accessor = [
    o: '. IdentifierNoUtils', (\-> $2);
    o: '. AlphaNumeric', (\-> $2);
  ]

  Arg = [
    o: 'Value';
    o: 'SExpression';
    o: 'ARGUMENTS';
  ]

  Arguments = [
    o: '!', (\-> none);
    o: 'Arg', (\-> construct Arguments: $1);
    o: 'Arguments Comma Arg', (\-> construct Arguments: $1, $3);
  ]

  Param = [
    o: 'Identifier';
    o: 'Identifier = Value', (\-> construct Assignment: $1, $3);
    o: 'Lists';
  ]

  Parameters = [
    o: '', (\-> none);
    o: 'Param', (\-> construct Arguments: $1);
    o: 'Parameters , Param', (\-> construct Arguments: $1, $3);
  ]

  Exceptions = [
    o: 'TRY Body CATCH Body', (\-> construct Exception: $2, $4);
  ]

  If = [
    o: 'IF Values OptTerminator THEN Body OptTerminator ELSE Body', (\-> construct If: $2, $5, $8);
  ]

  Operation = [
    o: 'Value COMPARE Value', (\-> construct Compare: $1, $2, $3);
    o: 'Value LOGIC Value', (\-> construct Compare: $1, $2, $3);
    o: 'Value OPERATORS Value', (\-> construct Operation: $1, $2, $3);
    o: 'NOT Value', (\-> construct Compare: $2, $1);
    o: 'Value + Value', (\-> construct Operation: $1, '+', $3);
    o: 'Value - Value', (\-> construct Operation: $1, '-', $3);
    o: 'Value * Value', (\-> construct Operation: $1, '*', $3);
    o: 'Value / Value', (\-> construct Operation: $1, '/', $3);
  ]
}


tokens = [
  'ASSERT', 'ARGUMENTS', 'IF', 'THEN', 'ELSE',
  'LAMBDA',
  'IDENTIFIER', 'BOOL', 'NUMBER', 'STRING',
  'LOGIC', 'COMPARE',
  'TERMINATOR'
]

operators = [
  ['right', 'NOT']
  ['right', 'IF', 'THEN', 'ELSE', 'IMPORT', 'EXPORT', 'ASSERT', 'ARGUMENTS']
  ['right', '=', '|']
  ['nonassoc', '(', ')', '[', ']', '{', '}', ':']
  ['left', 'LOGIC']
  ['left', 'COMPARE']
  ['left', 'OPERATORS']
  ['left', '+', '-']
  ['left', '*', '/']
]

Parser = jison.Parser
grammar = {
  tokens = tokens
  bnf = bnf
  operators = operators
  startSymbol = 'Root'
}

parser = construct Parser: grammar
fs.writeFileSync: './lib/parser.js', (parser.generate:!), 'utf8'
