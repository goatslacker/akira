// Generated by Akira v0.0.1
(function () {
  var escodegen, dune, lexer, implicitReturn, _$m, parser, me, prelude, HEADER, OPTIONS, makeProgram, transform, genProgramAst, transpile, replify, run;
  escodegen = require('escodegen');
  dune = require('dune');
  lexer = require('./lexer');
  implicitReturn = require('implicitReturn');
  _$m = require('./parser');
  parser = _$m.parser;
  parser.yy = require('../lang/nodes');
  parser.lexer = {
    lex: function () {
      var ref;
      ref = this.tokens[this.pos] || [''];
      this.pos = this.pos + 1;
      this.yytext = ref[1];
      this.yylineno = ref[2];
      return ref[0];
    },
    setInput: function (tokens) {
      this.tokens = tokens;
      return this.pos = 0;
    }
  };
  me = require('../../package.json');
  prelude = require('prelude');
  HEADER = ' Generated by Akira v'.concat(me.version);
  OPTIONS = {
    format: {
      indent: {
        style: '  ',
        base: 0
      }
    },
    comment: true,
    directive: true
  };
  makeProgram = function (body, context) {
    var exported;
    exported = context['$$$exported'];
    exported ? body.push(exported) : null;
    implicitReturn(body);
    return {
      type: 'Program',
      body: [{
          type: 'ExpressionStatement',
          expression: {
            type: 'CallExpression',
            callee: {
              type: 'FunctionExpression',
              id: null,
              params: [],
              body: {
                type: 'BlockStatement',
                body: body
              }
            },
            arguments: []
          },
          leadingComments: [{
              type: 'Line',
              value: HEADER
            }]
        }]
    };
  };
  transform = function (name, parsed) {
    var context, body, dependencies, programBody;
    return function () {
      switch (false) {
      case !(parsed === null):
        return makeProgram('', {});
      default:
        context = {};
        parser.parse(lexer(prelude)).compile({}, 'prelude');
        body = parsed.compile(context, name);
        dependencies = parsed.addDeps(context);
        parsed.flagCoreMethods(body);
        programBody = parsed.addVars(context).concat(parsed.addCore(), dependencies, parsed.addContracts(body));
        return makeProgram(programBody, context);
      }
    }.apply(this, arguments);
  };
  genProgramAst = function (name, code) {
    return transform(name, parser.parse(lexer(code)));
  };
  transpile = function (name, code) {
    return escodegen.generate(genProgramAst(name, code), OPTIONS);
  };
  replify = function (name, code) {
    var ast, program;
    ast = genProgramAst(name, code);
    program = {
      type: 'Program',
      body: [{
          type: 'ExpressionStatement',
          expression: {
            type: 'AssignmentExpression',
            operator: '=',
            left: {
              type: 'MemberExpression',
              object: {
                type: 'Identifier',
                name: 'this'
              },
              property: {
                type: 'Identifier',
                name: '_$resultValue'
              }
            },
            right: ast.body[0].expression
          }
        }]
    };
    return escodegen.generate(program, OPTIONS);
  };
  run = function (name, code, context) {
    try {
      return dune.string(code, name, context);
    } catch (err) {
      console.error(name);
      console.error(err.stack);
      return null;
    }
  };
  return module.exports = {
    genProgramAst: genProgramAst,
    lexer: lexer,
    run: run,
    transpile: transpile,
    replify: replify
  };
}());