// Generated by Akira v0.0.1
(function () {
  var ast, CallExpression, FunctionExpression, Identifier, MemberExpression, xthen, PromiseNode, supportedAsyncFns, parallel, xchangeIfAsyncCaller, Await;
  var any = function (f, vec) {
    return Array.prototype.some.call(vec, function () {
      return f(arguments[0]);
    });
  };
  var map = function (f, vec) {
    return Array.prototype.map.call(vec, function () {
      return f(arguments[0]);
    });
  };
  ast = require('ast');
  CallExpression = require('ast/CallExpression');
  FunctionExpression = require('ast/FunctionExpression');
  Identifier = require('ast/Identifier');
  MemberExpression = require('ast/MemberExpression');
  xthen = Identifier('then');
  PromiseNode = Identifier('Promise');
  PromiseNode.__core = true;
  supportedAsyncFns = [
    'map',
    'filter'
  ];
  parallel = Identifier('parallel');
  parallel.__core = true;
  xchangeIfAsyncCaller = function (call) {
    var name, xform;
    name = call.callee.name;
    xform = any(function () {
      return arguments[0] === name;
    }, supportedAsyncFns);
    return xform === true ? CallExpression(MemberExpression(PromiseNode, call.callee), call.arguments) : call;
  };
  Await = function () {
    var _$Class;
    _$Class = function (call, parallel) {
      this.call = call;
      this.parallel = parallel;
      this;
    };
    _$Class.prototype.compile = function (context) {
      var call, callback, caller, node;
      call = this.parallel === true ? CallExpression(parallel, map(function () {
        return ast(arguments[0], context);
      }, this.call.args)) : ast(this.call, context);
      callback = FunctionExpression(null, [], []);
      caller = call.callee.type === 'Identifier' ? xchangeIfAsyncCaller(call) : call;
      node = CallExpression(MemberExpression(caller, xthen), [callback]);
      node.__await = true;
      return node;
    };
    return _$Class;
  }.apply(this, arguments);
  return module.exports = Await;
}());