// Generated by Akira v0.0.1
!function() {
function any(f,a){if(arguments.length==1)return function(a){return any(f,a);};var i=0,l=a.length;for(i;i<l;i+=1)if(f(a[i]))return true;return false;}function map(f,a){if(arguments.length==1)return function(a){return map(f,a);};var i=0,l=a.length,r=Array(l);for(i;i<l;i+=1)r[i]=f(a[i]);return r;}
var ast, CallExpression, FunctionExpression, Identifier, MemberExpression, xthen, PromiseNode, supportedAsyncFns, parallel, xchangeIfAsyncCaller, Await;
ast = require('ast');
CallExpression = require('ast/CallExpression');
FunctionExpression = require('ast/FunctionExpression');
Identifier = require('ast/Identifier');
MemberExpression = require('ast/MemberExpression');
xthen = Identifier('then');
PromiseNode = Identifier('Promise');
PromiseNode.__core = true;
supportedAsyncFns = [
  'map',
  'filter'
];
parallel = Identifier('parallel');
parallel.__core = true;
xchangeIfAsyncCaller = function (call) {
  var name, xform;
  name = call.callee.name;
  xform = any(function () {
    return arguments[0] === name;
  }, supportedAsyncFns);
  return xform === true ? CallExpression(MemberExpression(PromiseNode, call.callee), call.arguments) : call;
};
Await = function () {
  var _$Class;
  _$Class = function (call, parallel) {
    this.call = call;
    this.parallel = parallel;
    this;
  };
  _$Class.prototype.compile = function (context) {
    var call, callback, caller, node;
    call = this.parallel === true ? CallExpression(parallel, map(function () {
      return ast(arguments[0], context);
    }, this.call.args)) : ast(this.call, context);
    callback = FunctionExpression(null, [], []);
    caller = call.callee.type === 'Identifier' ? xchangeIfAsyncCaller(call) : call;
    node = CallExpression(MemberExpression(caller, xthen), [callback]);
    node.__await = true;
    return node;
  };
  return _$Class;
}.apply(this, arguments);
return module.exports = Await;
}();