// Generated by Akira v0.0.1
!function() {
var copy=function(x,y){var keys;keys=Object.keys(y);keys.forEach(function(k){return x[k]=y[k];});return x;};var zipWith=function(f,_$fv1,_$fv2){var a,as,b,bs;a=_$fv1[0];as=_$fv1.slice(1,_$fv1.length-0);b=_$fv2[0];bs=_$fv2.slice(1,_$fv2.length-0);return typeof a==='undefined'||typeof b==='undefined'?[]:[f(a,b)].concat(zipWith(f,as,bs));};function map(f,a){if(arguments.length==1)return function(a){return map(f,a);};var i=0,l=a.length,r=Array(l);for(i;i<l;i+=1)r[i]=f(a[i]);return r;}
var CallExpression, ExpressionStatement, Identifier, MemberExpression, Store, TypeSystem, ast, escodegen, esprima, obj2str, unwrapExpressionStatement, vm, runMacro, typeCheckParams, verifyNumberParams, verifyTypes, unwrap, returnFunction, Call;
CallExpression = require('ast/CallExpression');
ExpressionStatement = require('ast/ExpressionStatement');
Identifier = require('ast/Identifier');
MemberExpression = require('ast/MemberExpression');
Store = require('Store');
TypeSystem = require('TypeSystem');
ast = require('ast');
escodegen = require('escodegen');
esprima = require('esprima');
obj2str = require('z/obj2str');
unwrapExpressionStatement = require('z/unwrapExpressionStatement');
vm = require('vm');
runMacro = function (name, xargs, context) {
  var ast, args, elements, code, scope;
  ast = Store.macros[name];
  args = esprima.parse(obj2str(xargs));
  elements = args.body[0].expression.elements || [];
  code = escodegen.generate(ExpressionStatement(CallExpression(ast, elements)));
  scope = copy(copy({}, context), this);
  return vm.runInNewContext(code, scope);
};
typeCheckParams = function (inferred, signed, context, line, name) {
  return zipWith(function (provided, expected) {
    return function () {
      if (a === null || b === null) {
        return null;
      } else {
        throw new TypeError(('Expected ' + (expected) + ' but got ' + (provided) + ' for function ' + (name) + ' ').concat('at ' + (context.$$$filename) + ' line ' + (line) + ''));
      }
    }.apply(this, arguments);
  }, inferred, signed);
};
verifyNumberParams = function (name, params, context, line) {
  var type, tparams, paramsUnbalanced;
  type = Store.types[name];
  tparams = type.params;
  return function () {
    if (tparams) {
      paramsUnbalanced = tparams.length !== params.length;
      return paramsUnbalanced === true ? console.warn(('' + (name) + ' was signed with ' + (tparams.length) + ' arguments yet it was provided with ' + (params.length) + ' ').concat('at ' + (context.$$$filename) + ' line ' + (line) + '')) : null;
    } else {
      return null;
    }
  }.apply(this, arguments);
};
verifyTypes = function (name, params, context, line) {
  var type, xparams;
  type = Store.types[name];
  return xparams = Object.prototype.toString.call(params) === '[object Array]' ? params : [];
};
unwrap = function (xargs) {
  return xargs ? map(unwrapExpressionStatement, xargs) : null;
};
returnFunction = function (callee, args, params, context, line) {
  Store.types[callee.name] ? verifyTypes(callee.name, args, context, line) : null;
  return args && args.__rest === true ? CallExpression(MemberExpression(callee, Identifier('apply')), [
    Identifier('null'),
    args
  ]) : params === 'apply' ? CallExpression(MemberExpression(callee, Identifier('apply')), [
    Identifier('null'),
    Identifier('arguments')
  ]) : CallExpression(callee, unwrap(args));
};
Call = function () {
  var _$Class;
  _$Class = function (ref, params) {
    this.ref = ref;
    this.params = params;
    this;
  };
  _$Class.prototype.compile = function (context) {
    var callee, args;
    callee = ast(this.ref, context);
    args = ast(this.params, context);
    return callee.type === 'Identifier' && Store.macros[callee.name] ? runMacro(callee.name, args, context) : returnFunction(callee, args, this.params, context, this.line);
  };
  return _$Class;
}.apply(this, arguments);
return module.exports = Call;
}();