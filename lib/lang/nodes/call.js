// Generated by Akira v0.0.1
(function () {
  var CallExpression, ExpressionStatement, Identifier, MemberExpression, Store, TypeSystem, ast, escodegen, esprima, obj2str, unwrapExpressionStatement, vm, runMacro, typeCheckParams, verifyNumberParams, verifyTypes, unwrap, returnFunction, Call;
  var copy = function (x, y) {
    Object.keys(y).forEach(function (k) {
      return x[k] = y[k];
    });
    return x;
  };
  var zipWith = function (f, _$fv1, _$fv2) {
    var a, as, b, bs;
    a = _$fv1[0];
    as = _$fv1.slice(1, _$fv1.length - 0);
    b = _$fv2[0];
    bs = _$fv2.slice(1, _$fv2.length - 0);
    return typeof a === 'undefined' || typeof b === 'undefined' ? [] : [f(a, b)].concat(zipWith(f, as, bs));
  };
  var map = function (f, vec) {
    return Array.prototype.map.call(vec, function () {
      return f(arguments[0]);
    });
  };
  CallExpression = require('ast/CallExpression');
  ExpressionStatement = require('ast/ExpressionStatement');
  Identifier = require('ast/Identifier');
  MemberExpression = require('ast/MemberExpression');
  Store = require('Store');
  TypeSystem = require('TypeSystem');
  ast = require('ast');
  escodegen = require('escodegen');
  esprima = require('esprima');
  obj2str = require('obj2str');
  unwrapExpressionStatement = require('unwrapExpressionStatement');
  vm = require('vm');
  runMacro = function (name, xargs, context) {
    var ast, args, elements, code, scope;
    ast = Store.macros[name];
    args = esprima.parse(obj2str(xargs));
    elements = args.body[0].expression.elements || [];
    code = escodegen.generate(ExpressionStatement(CallExpression(ast, elements)));
    scope = copy(copy({}, context), this);
    return vm.runInNewContext(code, scope);
  };
  typeCheckParams = function (provided, expected, context, line, name) {
    return zipWith(function (a, b) {
      return function () {
        if (a === null || b === null) {
          return null;
        } else {
          return function () {
            if (a !== b) {
              throw new TypeError(('Expected ' + (b) + ' but got ' + (a) + ' for function ' + (name) + ' ').concat('at ' + (context.$$$filename) + ' line ' + (line) + ''));
            } else {
              return null;
            }
          }.apply(this, arguments);
        }
      }.apply(this, arguments);
    }, provided, expected);
  };
  verifyNumberParams = function (name, params, context, line) {
    var type, tparams, paramsUnbalanced;
    type = Store.types[name];
    console.log(type)
    tparams = type.params;
    return function () {
      if (tparams) {
        paramsUnbalanced = tparams.length !== params.length;
        return paramsUnbalanced === true ? console.warn(('' + (name) + ' was signed with ' + (tparams.length) + ' ').concat('arguments yet it was provided with ' + (params.length) + ' ', 'at ' + (context.$$$filename) + ' line ' + (line) + '')) : null;
      } else {
        return null;
      }
    }.apply(this, arguments);
  };
  verifyTypes = function (name, params, context, line) {
    var type, xparams, inferredParams, akiraParamTypes;
    type = Store.types[name];
    xparams = Object.prototype.toString.call(params) === '[object Array]' ? params : [];
    verifyNumberParams(name, xparams, context, line);
    inferredParams = map(function () {
      return TypeSystem.infer(arguments[0], context);
    }, xparams);
    akiraParamTypes = type.params ? map(TypeSystem.convertAkiraType, type.params) : [];
    return akiraParamTypes.length && inferredParams.length ? typeCheckParams(inferredParams, akiraParamTypes, context, line, name) : null;
  };
  unwrap = function (xargs) {
    return xargs ? map(unwrapExpressionStatement, xargs) : null;
  };
  returnFunction = function (callee, args, params, context, line) {
    Store.types[callee.name] ? verifyTypes(callee.name, args, context, line) : null;
    return args && args.__rest === true ? CallExpression(MemberExpression(callee, Identifier('apply')), [
      Identifier('null'),
      args
    ]) : params === 'apply' ? CallExpression(MemberExpression(callee, Identifier('apply')), [
      Identifier('null'),
      Identifier('arguments')
    ]) : CallExpression(callee, unwrap(args));
  };
  Call = function () {
    var _$Class;
    _$Class = function (ref, params) {
      this.ref = ref;
      this.params = params;
      this;
    };
    _$Class.prototype.compile = function (context) {
      var callee, args;
      callee = ast(this.ref, context);
      args = ast(this.params, context);
      return callee.type === 'Identifier' && Store.macros[callee.name] ? runMacro(callee.name, args, context) : returnFunction(callee, args, this.params, context, this.line);
    };
    return _$Class;
  }.apply(this, arguments);
  return module.exports = Call;
}());
