// Generated by Akira v0.0.1
(function () {
  var CallExpression, ExpressionStatement, Identifier, MemberExpression, Store, TypeSystem, ast, escodegen, esprima, obj2str, unwrapExpressionStatement, vm, runMacro, typeCheckParams, checkCallType, unwrap, returnFunction, checkCalleeType, Call;
  var copy = function (x, y) {
    Object.keys(y).forEach(function (k) {
      return x[k] = y[k];
    });
    return x;
  };
  var zipWith = function (f, _$fv1, _$fv2) {
    var a, as, b, bs;
    a = _$fv1[0];
    as = _$fv1.slice(1, _$fv1.length - 0);
    b = _$fv2[0];
    bs = _$fv2.slice(1, _$fv2.length - 0);
    return typeof a === 'undefined' || typeof b === 'undefined' ? [] : [f(a, b)].concat(zipWith(f, as, bs));
  };
  var foldl = function (f, vec, a) {
    var reduce, reducer;
    reduce = Array.prototype.reduce;
    reducer = function () {
      return f(arguments[0], arguments[1]);
    };
    return function () {
      if (vec.length === 0) {
        return [];
      } else {
        return typeof a === 'undefined' ? reduce.call(vec, reducer) : reduce.call(vec, reducer, a);
      }
    }.apply(this, arguments);
  };
  var and = function (a, b) {
    return a && b;
  };
  var map = function (f, vec) {
    return Array.prototype.map.call(vec, function () {
      return f(arguments[0]);
    });
  };
  CallExpression = require('ast/CallExpression');
  ExpressionStatement = require('ast/ExpressionStatement');
  Identifier = require('ast/Identifier');
  MemberExpression = require('ast/MemberExpression');
  Store = require('Store');
  TypeSystem = require('TypeSystem');
  ast = require('ast');
  escodegen = require('escodegen');
  esprima = require('esprima');
  obj2str = require('obj2str');
  unwrapExpressionStatement = require('unwrapExpressionStatement');
  vm = require('vm');
  runMacro = function (name, xargs, context) {
    var ast, args, elements, code, scope;
    ast = Store.macros[name];
    args = esprima.parse(obj2str(xargs));
    elements = args.body[0].expression.elements || [];
    code = escodegen.generate(ExpressionStatement(CallExpression(ast, elements)));
    scope = copy(copy({}, context), this);
    return vm.runInNewContext(code, scope);
  };
  typeCheckParams = function (inferred, actual, context, line, name) {
    var combined, matched;
    combined = zipWith(function (a, b) {
      return a === null || b === null ? true : a === b;
    }, inferred, actual);
    matched = foldl(and, combined, true);
    return function () {
      if (!matched) {
        throw new TypeError(('' + (name) + ' was provided with an incorrect parameter ').concat('at ' + (context.$$$filename) + ' line ' + (line) + ''));
      } else {
        return null;
      }
    }.apply(this, arguments);
  };
  checkCallType = function (name, params, context, line) {
    var type, inferredParams, akiraParamTypes, tparams, paramsUnbalanced;
    if (params === void 0)
      params = [];
    type = Store.types[name];
    return function () {
      if (type) {
        inferredParams = map(function () {
          return TypeSystem.infer(arguments[0], context);
        }, params);
        akiraParamTypes = type.params ? map(TypeSystem.convertAkiraType, type.params) : [];
        akiraParamTypes.length && inferredParams.length ? typeCheckParams(inferredParams, akiraParamTypes, context, line, name) : null;
        tparams = type.params;
        return function () {
          if (tparams && params) {
            paramsUnbalanced = tparams.length !== params.length;
            return paramsUnbalanced === true ? console.warn(('' + (name) + ' was signed with ' + (tparams.length) + ' ').concat('arguments yet it was provided with ' + (params.length) + ' ', 'at ' + (context.$$$filename) + ' line ' + (line) + '')) : null;
          } else {
            return null;
          }
        }.apply(this, arguments);
      } else {
        return null;
      }
    }.apply(this, arguments);
  };
  unwrap = function (xargs) {
    return xargs ? map(unwrapExpressionStatement, xargs) : null;
  };
  returnFunction = function (callee, args, params, context, line) {
    checkCallType(callee.name, args, context, line);
    return args && args.__rest === true ? CallExpression(MemberExpression(callee, Identifier('apply')), [
      Identifier('null'),
      args
    ]) : params === 'apply' ? CallExpression(MemberExpression(callee, Identifier('apply')), [
      Identifier('null'),
      Identifier('arguments')
    ]) : CallExpression(callee, unwrap(args));
  };
  checkCalleeType = function (node) {
    return function () {
      if (node.type === 'Literal') {
        throw new TypeError('Cannot call using a Literal');
      } else {
        return null;
      }
    }.apply(this, arguments);
  };
  Call = function () {
    var _$Class;
    _$Class = function (ref, params) {
      this.ref = ref;
      this.params = params;
      this;
    };
    _$Class.prototype.compile = function (context) {
      var callee, args;
      callee = ast(this.ref, context);
      args = ast(this.params, context);
      checkCalleeType(callee);
      return callee.type === 'Identifier' && Store.macros[callee.name] ? runMacro(callee.name, args, context) : returnFunction(callee, args, this.params, context, this.line);
    };
    return _$Class;
  }.apply(this, arguments);
  module.exports = Call;
}());