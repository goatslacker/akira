// Generated by Akira v0.0.1
(function () {
  var CallExpression, ExpressionStatement, Identifier, MemberExpression, Store, TypeSystem, ast, escodegen, esprima, obj2str, unwrapExpressionStatement, vm, runMacro, checkCallType, unwrap, returnFunction, Call;
  var map = function (f, vec) {
    return Array.prototype.map.call(vec, function () {
      return f(arguments[0]);
    });
  };
  CallExpression = require('ast/CallExpression');
  ExpressionStatement = require('ast/ExpressionStatement');
  Identifier = require('ast/Identifier');
  MemberExpression = require('ast/MemberExpression');
  Store = require('Store');
  TypeSystem = require('TypeSystem');
  ast = require('ast');
  escodegen = require('escodegen');
  esprima = require('esprima');
  obj2str = require('obj2str');
  unwrapExpressionStatement = require('unwrapExpressionStatement');
  vm = require('vm');
  runMacro = function (name, xargs, context) {
    var ast, args, elements, code, scope, self;
    ast = Store.macros[name];
    args = esprima.parse(obj2str(xargs));
    elements = args.body[0].expression.elements || [];
    code = escodegen.generate(ExpressionStatement(CallExpression(ast, elements)));
    scope = {};
    self = this;
    Object.keys(self).forEach(function (k) {
      return scope[k] = self[k];
    });
    Object.keys(context).forEach(function (k) {
      return scope[k] = context[k];
    });
    return vm.runInNewContext(code, scope);
  };
  checkCallType = function (name, params, context, line) {
    var type, tparams, paramsUnbalanced;
    type = Store.types[name];
    return function () {
      if (type) {
        tparams = type.params;
        return function () {
          if (tparams && params) {
            paramsUnbalanced = tparams.length !== params.length;
            return paramsUnbalanced === true ? console.warn(('' + (name) + ' was signed with ' + (tparams.length) + ' ').concat('arguments yet it was provided with ' + (params.length) + ' ', 'at ' + (context.$$$filename) + ' line ' + (line) + '')) : null;
          } else {
            return null;
          }
        }.apply(this, arguments);
      } else {
        return null;
      }
    }.apply(this, arguments);
  };
  unwrap = function (xargs) {
    return xargs ? map(unwrapExpressionStatement, xargs) : null;
  };
  returnFunction = function (callee, args, params, context, line) {
    checkCallType(callee.name, args, context, line);
    return args && args.__rest === true ? CallExpression(MemberExpression(callee, Identifier('apply')), [
      Identifier('null'),
      args
    ]) : params === 'apply' ? CallExpression(MemberExpression(callee, Identifier('apply')), [
      Identifier('null'),
      Identifier('arguments')
    ]) : CallExpression(callee, unwrap(args));
  };
  Call = function () {
    var _$Class;
    _$Class = function (ref, params) {
      this.ref = ref;
      this.params = params;
      this;
    };
    _$Class.prototype.compile = function (context) {
      var callee, args;
      callee = ast(this.ref, context);
      args = ast(this.params, context);
      return callee.type === 'Identifier' && Store.macros[callee.name] ? runMacro(callee.name, args, context) : returnFunction(callee, args, this.params, context, this.line);
    };
    return _$Class;
  }.apply(this, arguments);
  module.exports = Call;
}());