// Generated by Akira v0.0.1
!function() {
function map(f,a){if(arguments.length==1)return function(a){return map(f,a);};var i=0,l=a.length,r=Array(l);for(i;i<l;i+=1)r[i]=f(a[i]);return r;}
var ExpressionStatement, Literal, ast, betaRedex, implicitReturn, makeArray, Cond;
ExpressionStatement = require('ast/ExpressionStatement');
Literal = require('ast/Literal');
ast = require('ast');
betaRedex = require('z/betaRedex');
implicitReturn = require('z/implicitReturn');
makeArray = require('z/makeArray');
Cond = function () {
  var _$Class;
  _$Class = function (patterns, def) {
    this.patterns = patterns.args.slice(0).concat([def.slice(0)]);
  };
  _$Class.prototype.compile = function (context) {
    var createPattern, body;
    createPattern = function (pattern) {
      var test, body;
      test = function () {
        if (pattern[0] === 'else') {
          return null;
        } else {
          return {
            type: 'UnaryExpression',
            operator: '!',
            argument: ast(pattern[0], context)
          };
        }
      }.apply(this, arguments);
      body = ast(pattern[1], context);
      return {
        type: 'SwitchCase',
        test: test,
        consequent: makeArray(ExpressionStatement(body))
      };
    }.bind(this);
    body = [{
        type: 'SwitchStatement',
        __cond: true,
        discriminant: Literal(false),
        cases: map(createPattern, this.patterns)
      }];
    implicitReturn(body);
    return betaRedex(body);
  };
  return _$Class;
}.apply(this, arguments);
return module.exports = Cond;
}();