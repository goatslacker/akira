// Generated by Akira v0.0.1
!function() {
function map(f,a){if(arguments.length==1)return function(a){return map(f,a);};var i=0,l=a.length,r=Array(l);for(i;i<l;i+=1)r[i]=f(a[i]);return r;}function foldl(f,a,s){if(arguments.length==1)return function(a,s){return foldl(f,a,s);};var i=0,l=a.length,v;if(s===undefined){if(!l)throw new Error(emptyList);v=a[i++];}else{v=s;}for(i;i<l;i+=1)v=f(v,a[i]);return v;}
var CallExpression, ExpressionStatement, Identifier, MemberExpression, Store, ast, createProp, createObject, Cloning;
CallExpression = require('ast/CallExpression');
ExpressionStatement = require('ast/ExpressionStatement');
Identifier = require('ast/Identifier');
MemberExpression = require('ast/MemberExpression');
Store = require('Store');
ast = require('ast');
createProp = function (prop) {
  return {
    type: 'Property',
    key: prop.key,
    value: {
      type: 'ObjectExpression',
      properties: [{
          type: 'Property',
          key: Identifier('value'),
          value: prop.value,
          kind: 'init'
        }]
    },
    kind: 'init'
  };
};
createObject = function (a, b) {
  var x;
  x = b.type === 'ObjectExpression' ? {
    type: 'ObjectExpression',
    properties: map(createProp, b.properties)
  } : b;
  return CallExpression(MemberExpression(Identifier('Object'), Identifier('create')), [
    CallExpression(Identifier('Object'), [a]),
    x
  ]);
};
Cloning = function () {
  var _$Class;
  _$Class = function (id, map) {
    this.id = id;
    this.map = map;
    this;
  };
  _$Class.prototype.compile = function (context) {
    var map, id, key;
    map = ast(this.map, context);
    id = ast(this.id, context);
    key = map.type === 'Identifier' ? context[map.name] : null;
    return map.type === 'ArrayExpression' || key && key.type === 'ArrayExpression' ? CallExpression(MemberExpression(map, Identifier('concat')), id) : foldl(createObject, [map].concat(id));
  };
  return _$Class;
}.apply(this, arguments);
return module.exports = Cloning;
}();