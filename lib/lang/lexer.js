// Generated by Akira v0.0.1
(function () {
  var rx, identifiers, ignore, getType, extract, parseAlphanumeric, returnIdentifier, parseIdentifier, convertRegexp, parseRegularExpressions, parseArgs, special, parseStr, getToken, processChunk, incrLine, getNextIndex, returnTokens, filterWhitespace, tokenize;
  var find = function (f, ds) {
    for (var i in ds) {
      if (f(ds[i]) === true) {
        return i;
      }
    }
  };
  var _$tg = require('tg').tg;
  rx = {
    IDENTIFIER: /^([a-zA-Z_$][0-9a-zA-Z_\-]*[\?]?)/,
    KEY: /^(@[a-zA-Z_$][0-9a-zA-Z_\-]*[\?]?)/,
    NUM: /^(-?([0-9]+[\.e])?[0-9]+,?)+/,
    STR: /^('(.*?)')/,
    ARGS: /^(&([0-9]+))/,
    LAMBDA: /^->/,
    OPERATION: /^(<<|<=|>=|>|<|(!|=)==?|\|\||\&\&|!!|\+\+|\+:|::)/,
    TERMINATOR: /^\n/,
    REGEXP: /^(\/((?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*)\/)([imgy]{0,4})(?!\w)/,
    COMMENTS: /^(--.*)/,
    WHITESPACE: /^ /
  };
  identifiers = {
    KEYWORDS: [
      'if',
      'then',
      'else',
      'import',
      'export',
      'try',
      'catch',
      'none',
      'do',
      'let',
      'fn',
      'raise',
      'prototype',
      'recur',
      'macro',
      'cond',
      'match',
      'interface',
      'Maybe',
      'Async',
      'class',
      'typealias',
      'async',
      'new',
      'await'
    ],
    COMPARE: [
      '==',
      '!=',
      '>',
      '>=',
      '<',
      '<=',
      'is',
      'isnt'
    ],
    INHERITANCE: ['<<'],
    ACCESSOR_OPERATOR: ['!!'],
    LEFT_OPERATORS: ['++'],
    RIGHT_OPERATORS: ['+:'],
    TYPE_OPERATOR: ['::'],
    NOT: ['not'],
    LOGIC: [
      '&&',
      '||'
    ],
    BOOL: [
      'true',
      'false'
    ]
  };
  ignore = {
    COMMENTS: 'COMMENTS',
    WHITESPACE: 'WHITESPACE'
  };
  getType = function (a) {
    return find(function () {
      return arguments[0].test(a);
    }, rx);
  };
  extract = function (key, chunk) {
    return rx[key].exec(chunk);
  };
  parseAlphanumeric = function (t, chunk, n) {
    if (n === void 0)
      n = 1;
    return extract(t, chunk)[n];
  };
  returnIdentifier = function (type, item) {
    switch (false) {
    case !(type === 'KEYWORDS' && arguments.length === 2):
      return [
        item.toUpperCase(),
        item,
        item
      ];
    case !(arguments.length === 2):
      return [
        type,
        item,
        item
      ];
    }
  };
  parseIdentifier = function (t, chunk) {
    var item, token;
    item = extract(t, chunk);
    token = find(function () {
      return arguments[0].indexOf(item[1]) >= 0;
    }, identifiers);
    return returnIdentifier(token || t, item[1]);
  };
  convertRegexp = function (item) {
    return RegExp(item[2], item[3]);
  };
  parseRegularExpressions = function () {
    return function () {
      return [
        'REGEXP',
        arguments[0],
        arguments[0]
      ];
    }(convertRegexp(extract.apply(null, arguments)));
  };
  parseArgs = function (type, chunk) {
    var token, raw;
    token = extract(type, chunk)[2];
    raw = extract(type, chunk)[0];
    return [
      type,
      token,
      raw
    ];
  };
  special = function (x) {
    switch (false) {
    case !(x === 'n' && arguments.length === 1):
      return '\n';
    case !(x === 'r' && arguments.length === 1):
      return '\r';
    case !(x === 't' && arguments.length === 1):
      return '\t';
    case !(x === 'b' && arguments.length === 1):
      return '\b';
    case !(x === 'f' && arguments.length === 1):
      return '\f';
    case !(arguments.length === 1):
      return x;
    }
  };
  parseStr = function (type, chunk) {
    var token, raw;
    token = function (str) {
      return str.replace(/\\([a-z])/g, function () {
        return special(arguments[1]);
      });
    }(extract(type, chunk)[2]);
    raw = extract(type, chunk)[0];
    return [
      type,
      token,
      raw
    ];
  };
  getToken = function (type, chunk) {
    return function () {
      switch (false) {
      case !(type === 'IDENTIFIER' || type === 'KEY' || type === 'OPERATION'):
        return parseIdentifier.apply(null, arguments);
      case !(type === 'NUM'):
        return parseAlphanumeric(type, chunk, 0);
      case !(type === 'STR'):
        return parseStr.apply(null, arguments);
      case !(type === 'COMMENTS'):
        return parseAlphanumeric.apply(null, arguments);
      case !(type === 'LAMBDA'):
        return 'FN';
      case !(type === 'REGEXP'):
        return parseRegularExpressions.apply(null, arguments);
      case !(type === 'ARGS'):
        return parseArgs.apply(null, arguments);
      case !(type === 'WHITESPACE' || type === 'TERMINATOR'):
        return ' ';
      default:
        return [
          chunk[0],
          chunk[0],
          chunk[0]
        ];
      }
    }.apply(this, arguments);
  };
  processChunk = function (code, n) {
    var type, token;
    type = getType(code);
    token = getToken(type, code);
    return Object.prototype.toString.call(token) === '[object Array]' ? token.concat([n.line]) : [
      type,
      token,
      token,
      n.line
    ];
  };
  incrLine = function (_$p0, line) {
    switch (false) {
    case !(_$p0 === 'TERMINATOR' && arguments.length === 2):
      return line + 1;
    default:
      return line;
    }
  };
  getNextIndex = function (token) {
    return {
      index: token[2].toString().length,
      token: token
    };
  };
  returnTokens = function (code, n, tokens) {
    var _$m, index, token;
    while (true) {
      switch (false) {
      case !(arguments.length === 2):
        return returnTokens(code, n, []);
      case !(code === '' && arguments.length === 3):
        return tokens;
      default:
        _$m = getNextIndex(processChunk(code, n));
        index = _$m.index;
        token = _$m.token;
        tokens.push(token);
        var _$r0 = code.substr(index, code.length);
        var _$r1 = { line: incrLine(token[0], n.line) };
        var _$r2 = tokens;
        code = _$r0;
        n = _$r1;
        tokens = _$r2;
        continue;
        return void 0;
      }
    }
  };
  filterWhitespace = function (token) {
    return !ignore[token[0]];
  };
  tokenize = function (code) {
    _$tg([String], [code]);
    return _$tg(Array, function () {
      return returnTokens(code, {
        index: 0,
        line: 0
      }).filter(filterWhitespace);
    }.apply(this, arguments));
  };
  return module.exports = tokenize;
}());