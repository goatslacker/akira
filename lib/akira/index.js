// Generated by Akira v0.0.1
(function () {
  var util, me, _$m, run, lexer, genProgramAst, transpile, writeFile, getAllFiles, getFile, repl, help, analyse, testFile, compile, toAst, make, runAFile, fileOutput, fileDebug, test, lex, _$929d8e, _$3763f2, _$884db1;
  var requireNodeAsync = function (m) {
    return Promise.promisifyAll(require(m));
  };
  var Promise = require('bluebird');
  var show = function (i) {
    return i.toString();
  };
  var flatten = function (vec, f) {
    var result;
    if (f === void 0)
      f = Array.isArray;
    result = [];
    vec.forEach(function (x) {
      return f(x) ? Array.prototype.push.apply(result, flatten(x)) : result.push(x);
    });
    return result;
  };
  var filter = function (f, vec) {
    return Array.prototype.filter.call(vec, function () {
      return f(arguments[0]);
    });
  };
  var print = function (args) {
    args = Array.prototype.slice.call(arguments, 0, arguments.length - 0);
    return Object.prototype.toString.call(console.log) === '[object Function]' ? console.log.apply(console, args) : null;
  };
  var foldl = function (f, vec, a) {
    var reduce, reducer;
    reduce = Array.prototype.reduce;
    reducer = function () {
      return f(arguments[0], arguments[1]);
    };
    return function () {
      if (vec.length === 0) {
        return [];
      } else {
        return typeof a === 'undefined' ? reduce.call(vec, reducer) : reduce.call(vec, reducer, a);
      }
    }.apply(this, arguments);
  };
  var and = function (a, b) {
    return a && b;
  };
  var zipWith = function (f, _$fv1, _$fv2) {
    var a, as, b, bs;
    a = _$fv1[0];
    as = _$fv1.slice(1, _$fv1.length - 0);
    b = _$fv2[0];
    bs = _$fv2.slice(1, _$fv2.length - 0);
    return typeof a === 'undefined' || typeof b === 'undefined' ? [] : [f(a, b)].concat(zipWith(f, as, bs));
  };
  var eq = function (a, b) {
    return a === b;
  };
  function map(f, a) {
    if (arguments.length == 1)
      return function (a) {
        return map(f, a);
      };
    var i = 0, l = a.length, r = Array(l);
    for (i; i < l; i += 1)
      r[i] = f(a[i]);
    return r;
  }
  var head = function (_$fv0) {
    var x;
    x = _$fv0[0];
    return x;
  };
  var tail = function (_$fv0) {
    var x, xs;
    x = _$fv0[0];
    xs = _$fv0.slice(1, _$fv0.length - 0);
    return xs;
  };
  _$929d8e = function () {
    var fs, path, File, getFile, getAllFiles, writeFile, functions;
    fs = requireNodeAsync('fs');
    path = require('path');
    File = function () {
      var _$Class;
      _$Class = function (name, code) {
        this.name = name;
        this.code = code;
        this;
      };
      return _$Class;
    }.apply(this, arguments);
    getFile = function (filepath) {
      var file, data;
      return new Promise(function (resolve, reject) {
        file = path.join(process.env.PWD, filepath);
        data = fs.readFileAsync(file).then(function (data) {
          resolve(new File(filepath, show(data)));
        }, reject);
      });
    };
    getAllFiles = function (filepath) {
      var st, ls, files, akiraFiles;
      return new Promise(function (resolve, reject) {
        st = fs.statAsync(filepath).then(function (st) {
          new Promise(function (resolve, reject) {
            if (st.isDirectory()) {
              ls = fs.readdirAsync(filepath).then(function (ls) {
                files = Promise.map(ls, function (file) {
                  var fullpath;
                  fullpath = path.join(filepath, file);
                  return getAllFiles(fullpath);
                }).then(function (files) {
                  resolve(flatten(files));
                }, reject);
              }, reject);
            } else {
              akiraFiles = filter(function () {
                return arguments[0].indexOf('.akira') >= 0;
              }, [filepath]);
              return Promise.map(akiraFiles, function () {
                return getFile(arguments[0]);
              }).then(resolve, reject);
            }
          }).then(resolve, reject);
        }, reject);
      });
    };
    writeFile = function (file, code, from, to) {
      var filename, writePath;
      if (to === void 0)
        to = path.dirname(file);
      return new Promise(function (resolve, reject) {
        filename = path.relative(from, file) || path.basename(file);
        writePath = path.join(to, filename.replace('.akira', '.js'));
        fs.writeFileAsync(writePath, code).then(resolve, reject);
      });
    };
    functions = {
      getAllFiles: getAllFiles,
      writeFile: writeFile,
      getFile: getFile
    };
    return functions;
  }();
  _$3763f2 = function () {
    var repl, context, vm, util, _$m, replify, inspect, readEvalPrintLoop, startRepl;
    repl = require('repl');
    context = { console: console };
    vm = require('vm');
    util = require('util');
    _$m = require('../lang/compiler.js');
    replify = _$m.replify;
    inspect = function (val) {
      return util.inspect(val, false, 35);
    };
    readEvalPrintLoop = function (data, _$fp1, filename, cb) {
      var code;
      try {
        code = replify(filename, data);
        vm.runInNewContext(code, context);
        return cb(context['_$resultValue']);
      } catch (err) {
        return util.error(err.stack);
      }
    };
    startRepl = function () {
      return repl.start({
        prompt: 'akira> ',
        input: process.stdin,
        output: process.stdout,
        eval: readEvalPrintLoop
      });
    };
    return startRepl;
  }();
  _$884db1 = function () {
    var text, help;
    text = [
      '',
      'ast [file]               - output the Mozilla Parse API for that file',
      'compile [file] [target]  - compile to JavaScript',
      'make [command] [args]    - run akira unit tests',
      'output [file]            - compile to JS and output',
      'repl                     - start the repl',
      'run [file]               - compile and interpret said file',
      'tokens [file]            - output the lexer tokens for that file',
      'version                  - akira version',
      'watch [file] [target]    - watch a file for changes and compile on change',
      ''
    ];
    help = function (invalid) {
      switch (false) {
      case !(arguments.length === 1):
        return print(['ERR Invalid command ' + (invalid) + ''].concat(text));
      default:
        return print(text);
      }
    };
    return help;
  }();
  util = require('util');
  me = require('../../package.json');
  _$m = require('../lang/compiler');
  run = _$m.run;
  lexer = _$m.lexer;
  genProgramAst = _$m.genProgramAst;
  transpile = _$m.transpile;
  _$m = _$929d8e;
  writeFile = _$m.writeFile;
  getAllFiles = _$m.getAllFiles;
  getFile = _$m.getFile;
  repl = _$3763f2;
  help = _$884db1;
  analyse = function (_$fp0, body) {
    return console.log(function () {
      return util.inspect(arguments[0], false, Infinity);
    }(body));
  };
  testFile = function (file) {
    var assertions, ok, okDeep, context, code;
    assertions = [];
    ok = function (a, b) {
      return assertions.push(a === b);
    };
    okDeep = function (a, b) {
      return ok(true, foldl(and, zipWith(eq, a, b)));
    };
    context = {
      ok: ok,
      okDeep: okDeep
    };
    code = transpile(file.name, file.code);
    run(file.name, code, context);
    return [
      file.name,
      foldl(and, assertions),
      assertions.length
    ];
  };
  compile = function (from, target) {
    var files;
    return new Promise(function (resolve, reject) {
      files = getAllFiles(from).then(function (files) {
        resolve(map(function (file) {
          var data;
          try {
            data = transpile(file.name, file.code);
            return writeFile(file.name, data, from, target).then(function () {
              return arguments[0];
            }, print);
          } catch (err) {
            console.error('Filename '.concat(file.name));
            console.error(err.stack);
            return process.exit(1);
          }
        }, files));
      }, reject);
    });
  };
  toAst = function (from, cb) {
    var files;
    if (cb === void 0)
      cb = analyse;
    return new Promise(function (resolve, reject) {
      files = getAllFiles(from).then(function (files) {
        resolve(map(function (file) {
          return cb(file.name, genProgramAst(file.name, file.code));
        }, files));
      }, reject);
    });
  };
  make = function (cmd, args) {
    var file, key, code;
    if (args === void 0)
      args = [];
    return new Promise(function (resolve, reject) {
      file = getFile('Make.akira').then(function (file) {
        key = cmd.replace(/[-+|:]([a-zA-Z0-9$_])/g, function (i) {
          return i[1].toUpperCase();
        });
        code = transpile(file.name, file.code);
        resolve(function () {
          return arguments[0](args);
        }(run(file.name, 'module.exports = '.concat(code))[key]));
      }, reject);
    });
  };
  runAFile = function (filename, context) {
    var file, code;
    return new Promise(function (resolve, reject) {
      file = getFile(filename).then(function (file) {
        code = transpile(file.name, file.code);
        resolve(run(file.name, code, context || {}));
      }, reject);
    });
  };
  fileOutput = function (filepath) {
    var files;
    return new Promise(function (resolve, reject) {
      files = getAllFiles(filepath).then(function (files) {
        resolve(map(function () {
          return console.log(transpile(arguments[0].name, arguments[0].code));
        }, files));
      }, reject);
    });
  };
  fileDebug = function (filepath) {
    var files;
    return new Promise(function (resolve, reject) {
      files = getAllFiles(filepath).then(function (files) {
        resolve(map(function () {
          return transpile(arguments[0].name, arguments[0].code);
        }, files));
      }, reject);
    });
  };
  test = function (filepath) {
    var testFiles;
    if (filepath === void 0)
      filepath = 'test';
    return new Promise(function (resolve, reject) {
      testFiles = getAllFiles(filepath).then(function (testFiles) {
        resolve(map(testFile, testFiles));
      }, reject);
    });
  };
  lex = function (filepath, cb) {
    var file;
    if (cb === void 0)
      cb = console.log;
    return new Promise(function (resolve, reject) {
      file = getFile(filepath).then(function (file) {
        resolve(cb(lexer(file.code)));
      }, reject);
    });
  };
  return module.exports = {
    cli: function (args) {
      var cmd, opts;
      cmd = head(args);
      opts = tail(args);
      return function () {
        switch (false) {
        case !(cmd === 'ast'):
          return toAst(opts[0]);
        case !(cmd === 'compile'):
          return compile(opts[0], opts[1]);
        case !(cmd === 'debug'):
          return map(fileDebug, opts);
        case !(cmd === 'help'):
          return help();
        case !(cmd === 'make'):
          return make(opts[0], tail(opts));
        case !(cmd === 'output'):
          return map(fileOutput, opts);
        case !(cmd === 'repl'):
          return repl();
        case !(cmd === 'run'):
          return runAFile(opts[0]);
        case !(cmd === 'test'):
          return test();
        case !(cmd === 'tokens'):
          return lex(opts[0]);
        case !(cmd === 'version'):
          return console.log('akira '.concat(me.version));
        default:
          return help(opts);
        }
      }.apply(this, arguments);
    },
    ast: toAst,
    compile: compile,
    debug: fileDebug,
    lexer: lex,
    output: fileOutput,
    repl: repl,
    run: runAFile,
    test: test,
    write: writeFile
  };
}());