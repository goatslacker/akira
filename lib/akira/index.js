// Generated by Akira v0.0.1
(function () {
  var util, me, _$m, run, lexer, genProgramAst, transpile, writeFile, getAllFiles, getFile, help, analyse, testFile, compile, toAst, make, runAFile, fileOutput, test, lex, _$73272e, _$929d8e, _$884db1;
  var requireNodeAsync = function (m) {
    return Promise.promisifyAll(require(m));
  };
  var Promise = require('bluebird');
  var show = function (i) {
    return i.toString();
  };
  var flatten = function (vec, f) {
    var result;
    if (f === void 0)
      f = Array.isArray;
    result = [];
    vec.forEach(function (x) {
      return f(x) ? Array.prototype.push.apply(result, flatten(x)) : result.push(x);
    });
    return result;
  };
  var filter = function (f, vec) {
    return Array.prototype.filter.call(vec, function () {
      return f(arguments[0]);
    });
  };
  var print = function (args) {
    args = Array.prototype.slice.call(arguments, 0, arguments.length - 0);
    return console.log.apply(console, args);
  };
  var foldl = function (f, vec, a) {
    var reduce, reducer;
    reduce = Array.prototype.reduce;
    reducer = function () {
      return f(arguments[0], arguments[1]);
    };
    return function () {
      if (vec.length === 0) {
        return [];
      } else {
        return typeof a === 'undefined' ? reduce.call(vec, reducer) : reduce.call(vec, reducer, a);
      }
    }.apply(this, arguments);
  };
  var and = function (a, b) {
    return a && b;
  };
  var zipWith = function (f, _$fv, _$fv) {
    var a, as, b, bs;
    a = _$fv[0];
    as = _$fv.slice(1, _$fv.length - 0);
    b = _$fv[0];
    bs = _$fv.slice(1, _$fv.length - 0);
    return typeof a === 'undefined' || typeof b === 'undefined' ? [] : [f(a, b)].concat(zipWith(f, as, bs));
  };
  var eq = function (a, b) {
    return a === b;
  };
  var map = function (f, vec) {
    return Array.prototype.map.call(vec, function () {
      return f(arguments[0]);
    });
  };
  var head = function (_$fv) {
    var x;
    x = _$fv[0];
    return x;
  };
  var tail = function (_$fv) {
    var x, xs;
    x = _$fv[0];
    xs = _$fv.slice(1, _$fv.length - 0);
    return xs;
  };
  _$73272e = function () {
    var escodegen, dune, lexer, parser, me, HEADER, OPTIONS, makeProgram, transform, genProgramAst, transpile, run;
    escodegen = require('escodegen');
    dune = require('dune');
    lexer = require('../lang/lexer');
    parser = require('../lang/grammar');
    parser.yy = require('../lang/nodes');
    me = require('../../package.json');
    HEADER = ' Generated by Akira v'.concat(me.version);
    OPTIONS = {
      format: {indent: {
          style: '  ',
          base: 0
        }},
      comment: true,
      directive: true
    };
    makeProgram = function (body) {
      return {
        type: 'Program',
        body: [{
            type: 'ExpressionStatement',
            expression: {
              type: 'CallExpression',
              callee: {
                type: 'FunctionExpression',
                id: null,
                params: [],
                body: {
                  type: 'BlockStatement',
                  body: body
                }
              },
              arguments: []
            },
            leadingComments: [{
                type: 'Line',
                value: HEADER
              }]
          }]
      };
    };
    transform = function (name, parsed) {
      var context, body, dependencies;
      return function () {
        switch (false) {
        case !(parsed === null):
          return makeProgram('');
        default:
          context = {};
          body = parsed.compile(context, name);
          dependencies = parsed.addDeps(context);
          parsed.flagCoreMethods(body);
          return makeProgram(parsed.addVars(context).concat(parsed.addCore(), dependencies, parsed.addContracts(body)));
        }
      }.apply(this, arguments);
    };
    genProgramAst = function (name, code) {
      return transform(name, parser.parse(lexer(code)));
    };
    transpile = function (name, code) {
      return escodegen.generate(genProgramAst(name, code), OPTIONS);
    };
    run = function (name, code, context) {
      try {
        return dune.string(code, name, context);
      } catch (err) {
        console.error(name);
        console.error(err.stack);
        return null;
      }
    };
    return {
      genProgramAst: genProgramAst,
      lexer: lexer,
      run: run,
      transpile: transpile
    };
  }();
  _$929d8e = function () {
    var fs, path, File, getFile, getAllFiles, writeFile;
    fs = requireNodeAsync('fs');
    path = require('path');
    File = function () {
      var _$Class;
      _$Class = function (name, code) {
        this.name = name;
        this.code = code;
        this;
      };
      return _$Class;
    }.apply(this, arguments);
    getFile = function (filepath) {
      var file, data;
      return new Promise(function (resolve, reject) {
        file = path.join(process.env.PWD, filepath);
        data = fs.readFileAsync(file).then(function (data) {
          resolve(new File(filepath, show(data)));
        }, reject);
      });
    };
    getAllFiles = function (filepath) {
      var st, ls, files, akiraFiles;
      return new Promise(function (resolve, reject) {
        st = fs.statAsync(filepath).then(function (st) {
          new Promise(function (resolve, reject) {
            if (st.isDirectory()) {
              ls = fs.readdirAsync(filepath).then(function (ls) {
                files = Promise.map(ls, function (file) {
                  var fullpath;
                  fullpath = path.join(filepath, file);
                  return getAllFiles(fullpath);
                }).then(function (files) {
                  resolve(flatten(files));
                }, reject);
              }, reject);
            } else {
              akiraFiles = filter(function () {
                return arguments[0].indexOf('.akira') >= 0;
              }, [filepath]);
              return Promise.map(akiraFiles, function () {
                return getFile(arguments[0]);
              }).then(resolve, reject);
            }
          }).then(resolve, reject);
        }, reject);
      });
    };
    writeFile = function (file, code, from, to) {
      var filename, writePath;
      if (to === void 0)
        to = path.dirname(file);
      return new Promise(function (resolve, reject) {
        filename = path.relative(from, file) || path.basename(file);
        writePath = path.join(to, filename.replace('.akira', '.js'));
        fs.writeFileAsync(writePath, code).then(resolve, reject);
      });
    };
    return {
      getAllFiles: getAllFiles,
      writeFile: writeFile,
      getFile: getFile
    };
  }();
  _$884db1 = function () {
    var text, help;
    text = [
      '',
      'ast [file]               - output the Mozilla Parse API for that file',
      'compile [file] [target]  - compile to JavaScript',
      'make [command] [args]    - run akira unit tests',
      'output [file]            - compile to JS and output',
      'repl                     - start the repl',
      'run [file]               - compile and interpret said file',
      'tokens [file]            - output the lexer tokens for that file',
      'version                  - akira version',
      'watch [file] [target]    - watch a file for changes and compile on change',
      ''
    ];
    help = function (invalid) {
      switch (false) {
      case !(arguments.length === 1):
        return print(['ERR Invalid command ' + (invalid) + ''].concat(text));
      default:
        return print(text);
      }
    };
    return help;
  }();
  util = require('util');
  me = require('../../package.json');
  _$m = _$73272e;
  run = _$m.run;
  lexer = _$m.lexer;
  genProgramAst = _$m.genProgramAst;
  transpile = _$m.transpile;
  _$m = _$929d8e;
  writeFile = _$m.writeFile;
  getAllFiles = _$m.getAllFiles;
  getFile = _$m.getFile;
  help = _$884db1;
  analyse = function (_$fp0, body) {
    return console.log(function () {
      return util.inspect(arguments[0], false, Infinity);
    }(body));
  };
  testFile = function (file) {
    var assertions, ok, okDeep, context, code;
    assertions = [];
    ok = function (a, b) {
      return assertions.push(a === b);
    };
    okDeep = function (a, b) {
      return ok(true, foldl(and, zipWith(eq, a, b)));
    };
    context = {
      ok: ok,
      okDeep: okDeep
    };
    code = transpile(file.name, file.code);
    run(file.name, code, context);
    return [
      file.name,
      foldl(and, assertions),
      assertions.length
    ];
  };
  compile = function (from, target) {
    var files;
    return new Promise(function (resolve, reject) {
      files = getAllFiles(from).then(function (files) {
        resolve(map(function (file) {
          var data;
          try {
            data = transpile(file.name, file.code);
            return writeFile(file.name, data, from, target).then(function () {
              return arguments[0];
            });
          } catch (err) {
            console.error('Filename '.concat(file.name));
            console.error(err.stack);
            return process.exit(1);
          }
        }, files));
      }, reject);
    });
  };
  toAst = function (from, cb) {
    var files;
    if (cb === void 0)
      cb = analyse;
    return new Promise(function (resolve, reject) {
      files = getAllFiles(from).then(function (files) {
        resolve(map(function (file) {
          return cb(file.name, genProgramAst(file.name, file.code));
        }, files));
      }, reject);
    });
  };
  make = function (cmd, args) {
    var file, key, code;
    if (args === void 0)
      args = [];
    return new Promise(function (resolve, reject) {
      file = getFile('Make.akira').then(function (file) {
        key = cmd.replace(/[-+|:]([a-zA-Z0-9$_])/g, function (i) {
          return i[1].toUpperCase();
        });
        code = transpile(file.name, file.code);
        resolve(function () {
          return arguments[0](args);
        }(run(file.name, 'module.exports = '.concat(code))[key]));
      }, reject);
    });
  };
  runAFile = function (filename, context) {
    var file, code;
    return new Promise(function (resolve, reject) {
      file = getFile(filename).then(function (file) {
        code = transpile(file.name, file.code);
        resolve(run(file.name, code, context || {}));
      }, reject);
    });
  };
  fileOutput = function (filepath) {
    var files;
    return new Promise(function (resolve, reject) {
      files = getAllFiles(filepath).then(function (files) {
        resolve(map(function () {
          return console.log(transpile(arguments[0].name, arguments[0].code));
        }, files));
      }, reject);
    });
  };
  test = function (filepath) {
    var testFiles;
    if (filepath === void 0)
      filepath = 'test';
    return new Promise(function (resolve, reject) {
      testFiles = getAllFiles(filepath).then(function (testFiles) {
        resolve(map(testFile, testFiles));
      }, reject);
    });
  };
  lex = function (filepath, cb) {
    var file;
    if (cb === void 0)
      cb = console.log;
    return new Promise(function (resolve, reject) {
      file = getFile(filepath).then(function (file) {
        resolve(cb(lexer(file.code)));
      }, reject);
    });
  };
  module.exports = {
    cli: function (args) {
      var cmd, opts;
      cmd = head(args);
      opts = tail(args);
      return function () {
        switch (false) {
        case !(cmd === 'ast'):
          return toAst(opts[0]);
        case !(cmd === 'compile'):
          return compile(opts[0], opts[1]);
        case !(cmd === 'help'):
          return help();
        case !(cmd === 'make'):
          return make(opts[0], tail(opts));
        case !(cmd === 'output'):
          return map(fileOutput, opts);
        case !(cmd === 'run'):
          return runAFile(opts[0]);
        case !(cmd === 'test'):
          return test();
        case !(cmd === 'tokens'):
          return lex(opts[0]);
        case !(cmd === 'version'):
          return console.log('akira '.concat(me.version));
        default:
          return help(opts);
        }
      }.apply(this, arguments);
    },
    ast: toAst,
    compile: compile,
    lexer: lex,
    output: fileOutput,
    run: runAFile,
    test: test,
    write: writeFile
  };
}());