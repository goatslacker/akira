var Store = require('Store')

function getType(obj) {
  var type = typeof obj;
  if (type === 'object') {
    switch (Object.prototype.toString.call(obj)) {
      case '[object Array]': return 'array';
      case '[object RegExp]': return 'regexp';
      case '[object Null]': return 'null';
      case '[object Date]': return 'date';
      default: return 'object';
    }
  } else {
    return type;
  }
}

function findIndex(node, property) {
}

function findKey(node, property) {
  if (property.type !== 'Identifier' && property.type !== 'Literal') {
    return {}
  }

  return (node.properties.filter(function (prop) {
    return prop.key.name === property.name
  })[0] || {}).value || {}
}

function lookupObj(object, property, context) {
  switch (object.type) {
    case 'Identifier':
      if (context.hasOwnProperty(object.name)) {
        var node = context[object.name]

        // XXX are these the only possible types?
        if (node.type === 'ObjectExpression') {
          return infer(findKey(node, property), context)
        }
        if (node.type === 'ArrayExpresion') {
          return infer(findIndex(node, property), context)
        }
      }
      return null
    case 'MemberExpression':
      return null
      debugger;
    case 'Literal':
      return null
      debugger;
    default:
      return null
  }
}

function typeOf(x) {
  var type = typeof x
  switch (type) {
    case 'object':
      if (Array.isArray(x)) {
        return 'array'
      }

      if (x === null) {
        return 'null'
      }

      return Object.prototype.toString.call(x)
        .toLowerCase()
        .replace(/\[object (.*)\]/, function (a, b) { return b })
    default:
      return type
  }
}

function convertAkiraType(x) {
  if (x.type === 'Identifier') {
    switch (x.name) {
      case 'Vector':
        return 'array'
      case 'Map':
        return 'object'
      default:
        return x.name.toLowerCase()
    }
  }
  return null
}

function infer(node, context) {
  if (node.__type) {
    return node.__type
  }

  switch (node.type) {
    case 'ExpressionStatement':
      return infer(node.expression, context)
    case 'Literal':
      return typeOf(node.value)
    case 'Identifier':
      if (context.hasOwnProperty(node.name)) {
        return infer(context[node.name], context)
      }
      if (context.$$$params && context.$$$params.args) {
        var arg = context.$$$params.args.reduce(function (result, param, i) {
          return result === null && param.name === node.name ? i : result
        }, null)
        if (arg !== null) {
          return { arguments: arg }
        }
      }
      return null
    case 'CallExpression':
      if (node.callee.type === 'Identifier') {
        if (Store.types.hasOwnProperty(node.callee.name)) {
          return convertAkiraType(Store.types[node.callee.name].retval)
        }
        if (context.hasOwnProperty(node.callee.name)) {
          var inferred = infer(context[node.callee.name], context)
          if (inferred && typeof inferred === 'object') {
            return infer(node.arguments[inferred.arguments], context)
          }
          return inferred
        }
      }
      return null
    case 'BinaryExpression':
      // XXX can only return numbers in our cases
      return 'number'
    case 'ArrayExpression':
      return 'array'
    case 'ObjectExpression':
      return 'object'
    case 'FunctionExpression':
      return 'function'
    case 'MemberExpression':
      return lookupObj(node.object, node.property, context)
    default:
      return null
  }
}

module.exports = {
  getType: getType,
  infer: infer,
  convertAkiraType: convertAkiraType
};
