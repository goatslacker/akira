var Store = require('Store')
var fu = require('fu')

function getObjProperty(obj) {
  return fu.head(fu.filter(function (x) {
    return obj.hasOwnProperty(x)
  }, ['or', 'maybe']))
}

function traverseObject(f, obj) {
  return fu.intoObject(fu.map(function (key) {
    return [key, f(obj[key])]
  }, Object.keys(obj)))
}

function traverseSignature(type, f) {
  var x = type.name ? type.name : type

  switch (toString.call(x)) {
    case '[object Object]':
      switch (getObjProperty(x)) {
        case 'or':
          return f.or(x.or)
        case 'maybe':
          return f.maybe(x.maybe)
        default:
          return f.obj(x.obj)
      }
    case '[object Array]':
      return f.array(x)
    default:
      switch (x.name) {
        case 'Boolean':
        case 'Number':
        case 'String':
        case 'Array':
        case 'Object':
          return f.single(x.name)
        default:
          return f.any(x.name)
      }
  }
}

function getType(obj) {
  var type = typeof obj;
  if (type === 'object') {
    switch (Object.prototype.toString.call(obj)) {
      case '[object Array]': return 'array';
      case '[object RegExp]': return 'regexp';
      case '[object Null]': return 'null';
      case '[object Date]': return 'date';
      default: return 'object';
    }
  } else {
    return type;
  }
}

function findIndex(node, property) {
}

function findKey(node, property) {
  if (property.type !== 'Identifier' && property.type !== 'Literal') {
    return {}
  }

  return (node.properties.filter(function (prop) {
    return prop.key.name === property.name
  })[0] || {}).value || {}
}

function lookupObj(object, property, context) {
  switch (object.type) {
    case 'Identifier':
      if (context.hasOwnProperty(object.name)) {
        var node = context[object.name]

        // XXX are these the only possible types?
        if (node.type === 'ObjectExpression') {
          return infer(findKey(node, property), context)
        }
        if (node.type === 'ArrayExpresion') {
          return infer(findIndex(node, property), context)
        }
      }
      return null
    case 'MemberExpression':
      return null
      debugger;
    case 'Literal':
      return null
      debugger;
    default:
      return null
  }
}

function typeOf(x) {
  var type = typeof x
  switch (type) {
    case 'object':
      if (Array.isArray(x)) {
        return 'array'
      }

      if (x === null) {
        return 'null'
      }

      return Object.prototype.toString.call(x)
        .toLowerCase()
        .replace(/\[object (.*)\]/, function (a, b) { return b })
    default:
      return type
  }
}

function convertAkiraType(x) {
  if (x.type === 'Identifier') {
    switch (x.name) {
      case 'Vector':
        return 'array'
      case 'Map':
        return 'object'
      default:
        return x.name.toLowerCase()
    }
  }
  return null
}

function infer(node, context) {
  if (node.__type) {
    return node.__type
  }

  switch (node.type) {
    case 'ExpressionStatement':
      return infer(node.expression, context)
    case 'Literal':
      return typeOf(node.value)
    case 'Identifier':
      if (context.hasOwnProperty(node.name)) {
        return infer(context[node.name], context)
      }
      if (context.$$$params && context.$$$params.args) {
        var arg = context.$$$params.args.reduce(function (result, param, i) {
          return result === null && param.name === node.name ? i : result
        }, null)
        if (arg !== null) {
          return { arguments: arg }
        }
      }
      return null
    case 'CallExpression':
      if (node.callee.type === 'Identifier') {
        if (Store.types.hasOwnProperty(node.callee.name)) {
          // XXX fix this
          return convertAkiraType(Store.types[node.callee.name].retval)
        }
        if (context.hasOwnProperty(node.callee.name)) {
          var inferred = infer(context[node.callee.name], context)
          if (inferred && typeof inferred === 'object') {
            return infer(node.arguments[inferred.arguments], context)
          }
          return inferred
        }
      }
      return null
    case 'BinaryExpression':
      // XXX can only return numbers in our cases
      return 'number'
    case 'ArrayExpression':
      return 'array'
    case 'ObjectExpression':
      return 'object'
    case 'FunctionExpression':
      return 'function'
    case 'MemberExpression':
      return lookupObj(node.object, node.property, context)
    default:
      return null
  }
}

module.exports = {
  getType: getType,
  infer: infer,
  traverseSignature: traverseSignature,
  traverseObject: traverseObject
};
