var AssignmentExpression = require('ast/AssignmentExpression');
var BinaryExpression = require('ast/BinaryExpression');
var CallExpression = require('ast/CallExpression');
var ChainedMemberExpression = require('ast/ChainedMemberExpression');
var FunctionExpression = require('ast/FunctionExpression');
var Identifier = require('ast/Identifier');
var Literal = require('ast/Literal');
var MemberExpression = require('ast/MemberExpression');
var addScope = require('addScope');
var ast = require('ast');
var destructure = require('destructure');
var implicitReturn = require('implicitReturn');
var traverse = require('traverse');

function createFunction(params, body, context, id) {
  if (!Array.isArray(body)) {
    body = [body];
  }

  implicitReturn(body);

  var recur = false;
  var last = traverse(body[body.length - 1], function (node) {
    if (!node.__recur) {
      return node;
    }

    if (!params) {
      throw new TypeError(
        'Tried to use recur somewhere without any parameters');
    }

    recur = true;

    return node.body.concat(node.body.map(function (arg, idx) {
      var param = params[idx++];

      if (Array.isArray(param)) {
        param = param[0].expression.left;
      }

      return {
        type: 'ExpressionStatement',
        expression: AssignmentExpression(param, arg.declarations[0].id)
      };
    }), { type: 'ContinueStatement', label: null });
  });

  if (recur) {
    body[body.length - 1] = last;
    body = [{
      type: 'WhileStatement',
      test: Literal(true),
      body: {
        type: 'BlockStatement',
        body: body
      }
    }];
  }

  var expressions = [];
  var tmpvar = '_$fp';

  if (params) {
    params = params.map(function (param, pi, ls) {
      var a;

      if (param.name === '_') {
        param.name = tmpvar + pi;
      }
      // TODO move this
      // TODO better check for this...
      if (Array.isArray(param)) {
        a = param[0].expression.left;

        // FIXME don't mutate
        delete context[a.name];
        expressions.push({
          type: 'IfStatement',
          test: BinaryExpression('===', ast(a, context), {
            type: 'UnaryExpression',
            operator: 'void',
            argument: Literal(0)
          }),
          consequent: param[0],
          alternate: null
        });
        return a;
      } else if (param.type === 'ArrayExpression') {
        expressions.push.apply(
          expressions,
          destructure(
            Identifier('_$fv' + pi),
            param,
            0,
            function () { },
            context
          )
        );

        return Identifier('_$fv' + pi);
      } else if (param.__rest) {
        expressions.push({
          type: 'ExpressionStatement',
          expression: AssignmentExpression(
            param,
            CallExpression(
              ChainedMemberExpression(
                Identifier('Array'),
                Identifier('prototype'),
                Identifier('slice'),
                Identifier('call')
              ),
              [
                Identifier('arguments'),
                Literal(pi),
                BinaryExpression(
                  '-',
                  MemberExpression(
                    Identifier('arguments'),
                    Identifier('length')
                  ),
                  Literal(ls.length - pi - 1)
                )
              ]
            )
          )
        });
      }

      return param;
    });

    body = expressions.concat(body);
  }

  body = addScope(context, body);

  return FunctionExpression(
    id || null,
    params || [],
    body
  );
}

module.exports = createFunction;
