module.exports = handleParams

var ast = require('ast')
var destructure = require('z/destructure')
var BinaryExpression = require('ast/BinaryExpression')
var IfStatement = require('ast/IfStatement')
var AssignmentExpression = require('ast/AssignmentExpression')
var ChainedMemberExpression = require('ast/ChainedMemberExpression')
var MemberExpression = require('ast/MemberExpression')
var CallExpression = require('ast/CallExpression')
var Identifier = require('ast/Identifier')
var Literal = require('ast/Literal')
var ExpressionStatement = require('ast/ExpressionStatement')

function handleParams(params, context) {
  var expressions = []
  var tmpvar = '_$fp'

  params = params || []

  params = params.map(function (param, pi, ls) {
    if (param.type === 'MemberExpression' && param.object.type === 'Identifier' && param.object.name === 'this') {
      expressions.push(ExpressionStatement(AssignmentExpression(
        param,
        param.property
      )))
      return param.property
    }

    if (param.name === '_') {
      param.name = tmpvar + pi;
    }
    // TODO move this
    // TODO better check for this...
    if (Array.isArray(param)) {
      var a = param[0].expression.left;

      // FIXME don't mutate
      delete context[a.name];
      expressions.push(
        IfStatement(
          BinaryExpression('===', ast(a, context), {
            type: 'UnaryExpression',
            operator: 'void',
            argument: Literal(0)
          }),
          param[0],
          null
        )
      );

      return a
    } else if (param.type === 'ArrayExpression' || param.type === 'ObjectExpression') {
      expressions.push.apply(
        expressions,
        destructure(
          Identifier('_$fpds' + pi),
          param,
          0,
          function () { },
          context
        )
      );

      return Identifier('_$fpds' + pi);
    } else if (param.__rest) {
      expressions.push({
        type: 'ExpressionStatement',
        expression: AssignmentExpression(
          param,
          CallExpression(
            ChainedMemberExpression(
              Identifier('Array'),
              Identifier('prototype'),
              Identifier('slice'),
              Identifier('call')
            ),
            [
              Identifier('arguments'),
              Literal(pi),
              BinaryExpression(
                '-',
                MemberExpression(
                  Identifier('arguments'),
                  Identifier('length')
                ),
                Literal(ls.length - pi - 1)
              )
            ]
          )
        )
      });
    }

    return param;
  });

  return {
    params: params,
    expressions: expressions,
    context: context
  }
}
