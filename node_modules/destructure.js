var CallExpression = require('ast/CallExpression');
var concatMap = require('concatMap');

function destructure(arg, dataStructure, idx, fn, context) {
  var tmpvar = '_$ds' + idx;

  var is_obj = false;
  var elements;
  var rest = false;

  switch (dataStructure.type) {
    case 'ArrayExpression':
      elements = dataStructure.elements;
      break;
    case 'ObjectExpression':
      elements = dataStructure.properties;
      is_obj = true;
      break;
  }

  return concatMap(function (node, index, ls) {
    if (context[node.name]) {
      return fn(node.name);
    }

// FIXME clean this up
    if (node.type !== 'Identifier' &&
      node.type !== 'ArrayExpression' &&
      node.type !== 'ObjectExpression' &&
      node.type !== 'Property') {
      return null;
    }

    if (node.type === 'ArrayExpression') {
      return destructure({
        type: 'MemberExpression',
        computed: true,
        object: arg,
        property: { type: 'Literal', value: index }
      }, node, idx + 1, fn, context);
    }
    if (node.type === 'ObjectExpression') {
      return destructure({
        type: 'MemberExpression',
        computed: true,
        object: arg,
        property: { type: 'Literal', value: index }
      }, node, idx + 1, fn, context);
    }
    if (node.type === 'Property' && node.value.type === 'ObjectExpression') {
      return destructure({
        type: 'MemberExpression',
        computed: false,
        object: arg,
        property: node.key
      }, node.value, idx + 1, fn, context);
    }

    if (node.name === '_') {
      node.name = tmpvar + index;
    }

    if (node.__rest) {
      rest = true;
      action = CallExpression({
        type: 'MemberExpression',
        computed: false,
        object: arg,
        property: { type: 'Identifier', name: 'slice' }
      }, [{
        type: 'Literal',
        value: index
      }, {
        type: 'BinaryExpression',
        operator: '-',
        left: {
          type: 'MemberExpression',
          computed: false,
          object: arg,
          property: { type: 'Identifier', name: 'length' }
        },
        right: {
          type: 'Literal',
          value: (ls.length - index - 1)
        }
      }]);
    // FIXME this is ugly
    // we should move this whole destructuring business out to it's own
    // file
    } else if (node.type === 'Property') {
      action = {
        type: 'MemberExpression',
        computed: false,
        object: arg,
        property: node.value.type === 'Identifier' ? node.value : node.key
      };
      node = node.key;
    } else {

      if (rest) {
        action = {
          type: 'MemberExpression',
          computed: true,
          object: arg,
          property: {
            type: 'BinaryExpression',
            operator: '-',
            left: {
              type: 'MemberExpression',
              computed: false,
              object: arg,
              property: { type: 'Identifier', name: 'length' }
            },
            right: {
              type: 'Literal',
              value: (ls.length - index)
            }
          }
        };
      } else {
        action = {
          type: 'MemberExpression',
          computed: true,
          object: arg,
          property: { type: 'Literal', value: index }
        };
      }
    }

    return context[node.name] = {
      type: 'ExpressionStatement',
      expression: {
        type: 'AssignmentExpression',
        operator: '=',
        left: node,
        right: action
      }
    };
  }, elements).filter(function (x) {
    return x !== null;
  });
}

module.exports = destructure;
